{"version":3,"sources":["../src/actions.ts","../src/cache.ts","../src/context.ts","../src/embedding.ts","../src/environment.ts","../src/evaluators.ts","../src/generation.ts","../src/goals.ts","../src/knowledge.ts","../src/logger.ts","../src/memory.ts","../src/parsing.ts","../src/messages.ts","../src/posts.ts","../src/providers.ts","../src/runtime.ts","../src/settings.ts","../src/types.ts","../src/uuid.ts","../src/models.ts"],"sourcesContent":["import {\r\n  composeActionExamples as coreComposeActionExamples,\r\n  formatActionNames as coreFormatActionNames,\r\n  formatActions as coreFormatActions,\r\n} from '@elizaos/core';\r\n\r\nimport type { Action, ActionExample } from \"./types.ts\";\r\n\r\n/**\r\n * Composes a set of example conversations based on provided actions and a specified count.\r\n * It randomly selects examples from the provided actions and formats them with generated names.\r\n * @param actionsData - An array of `Action` objects from which to draw examples.\r\n * @param count - The number of examples to generate.\r\n * @returns A string containing formatted examples of conversations.\r\n */\r\nexport const composeActionExamples = (actionsData: Action[], count: number) => {\r\n  return coreComposeActionExamples(actionsData, count);\r\n}\r\n\r\n/**\r\n * Formats the names of the provided actions into a comma-separated string.\r\n * @param actions - An array of `Action` objects from which to extract names.\r\n * @returns A comma-separated string of action names.\r\n */\r\nexport function formatActionNames(actions: Action[]) {\r\n  return coreFormatActionNames(actions);\r\n}\r\n\r\n/**\r\n * Formats the provided actions into a detailed string listing each action's name and description, separated by commas and newlines.\r\n * @param actions - An array of `Action` objects to format.\r\n * @returns A detailed string of actions, including names and descriptions.\r\n */\r\nexport function formatActions(actions: Action[]) {\r\n  return coreFormatActions(actions);\r\n}","import {\r\n  MemoryCacheAdapter as coreMemoryCacheAdapter,\r\n  FsCacheAdapter as coreFsCacheAdapter,\r\n  DbCacheAdapter as coreDbCacheAdapter,\r\n  CacheManager as coreCacheManager,\r\n} from '@elizaos/core';\r\n\r\nimport type {\r\n    CacheOptions,\r\n    ICacheManager,\r\n    IDatabaseCacheAdapter,\r\n    UUID,\r\n} from \"./types\";\r\n\r\nexport interface ICacheAdapter {\r\n    get(key: string): Promise<string | undefined>;\r\n    set(key: string, value: string): Promise<void>;\r\n    delete(key: string): Promise<void>;\r\n}\r\n\r\nexport class MemoryCacheAdapter implements ICacheAdapter {\r\n    _adapter: coreMemoryCacheAdapter;\r\n\r\n    constructor(initalData?: Map<string, string>) {\r\n        this._adapter = new coreMemoryCacheAdapter(initalData);\r\n    }\r\n\r\n    async get(key: string): Promise<string | undefined> {\r\n        return this._adapter.get(key);\r\n    }\r\n\r\n    async set(key: string, value: string): Promise<void> {\r\n        return this._adapter.set(key, value);\r\n    }\r\n\r\n    async delete(key: string): Promise<void> {\r\n        return this._adapter.delete(key);\r\n    }\r\n}\r\n\r\nexport class FsCacheAdapter implements ICacheAdapter {\r\n    _adapter: coreFsCacheAdapter;\r\n    constructor(private dataDir: string) {\r\n        this._adapter = new coreFsCacheAdapter(dataDir);\r\n    }\r\n\r\n    async get(key: string): Promise<string | undefined> {\r\n        return this._adapter.get(key);\r\n    }\r\n\r\n    async set(key: string, value: string): Promise<void> {\r\n        return this._adapter.set(key, value);\r\n    }\r\n\r\n    async delete(key: string): Promise<void> {\r\n        return this._adapter.delete(key);\r\n    }\r\n}\r\n\r\nexport class DbCacheAdapter implements ICacheAdapter {\r\n    _adapter: coreDbCacheAdapter;\r\n    constructor(\r\n        private db: IDatabaseCacheAdapter,\r\n        private agentId: UUID\r\n    ) {\r\n        this._adapter = new coreDbCacheAdapter(db, agentId);\r\n    }\r\n\r\n    async get(key: string): Promise<string | undefined> {\r\n        return this._adapter.get(key);\r\n    }\r\n\r\n    async set(key: string, value: string): Promise<void> {\r\n        return this._adapter.set(key, value);\r\n    }\r\n\r\n    async delete(key: string): Promise<void> {\r\n        return this._adapter.delete(key);\r\n    }\r\n}\r\n\r\nexport class CacheManager<CacheAdapter extends ICacheAdapter = ICacheAdapter>\r\n    implements ICacheManager\r\n{\r\n    _adapter: coreCacheManager;\r\n    adapter: CacheAdapter;\r\n\r\n    constructor(adapter: CacheAdapter) {\r\n        this._adapter = new coreCacheManager(adapter);\r\n        this.adapter = adapter;\r\n    }\r\n\r\n    async get<T = unknown>(key: string): Promise<T | undefined> {\r\n        return this._adapter.get(key);\r\n    }\r\n\r\n    async set<T>(key: string, value: T, opts?: CacheOptions): Promise<void> {\r\n        return this._adapter.set(key, value, opts);\r\n    }\r\n\r\n    async delete(key: string): Promise<void> {\r\n        return this._adapter.delete(key);\r\n    }\r\n}","import {\r\n  composeContext as coreComposeContext,\r\n  addHeader as coreAddHeader,\r\n  composeRandomUser as coreComposeRandomUser,\r\n} from '@elizaos/core';\r\nimport type { State, TemplateType } from \"./types.ts\";\r\n\r\n/**\r\n * Composes a context string by replacing placeholders in a template with corresponding values from the state.\r\n *\r\n * This function takes a template string with placeholders in the format `{{placeholder}}` and a state object.\r\n * It replaces each placeholder with the value from the state object that matches the placeholder's name.\r\n * If a matching key is not found in the state object for a given placeholder, the placeholder is replaced with an empty string.\r\n *\r\n * By default, this function uses a simple string replacement approach. However, when `templatingEngine` is set to `'handlebars'`, it uses Handlebars templating engine instead, compiling the template into a reusable function and evaluating it with the provided state object.\r\n *\r\n * @param {Object} params - The parameters for composing the context.\r\n * @param {State} params.state - The state object containing values to replace the placeholders in the template.\r\n * @param {TemplateType} params.template - The template string or function containing placeholders to be replaced with state values.\r\n * @param {\"handlebars\" | undefined} [params.templatingEngine] - The templating engine to use for compiling and evaluating the template (optional, default: `undefined`).\r\n * @returns {string} The composed context string with placeholders replaced by corresponding state values.\r\n *\r\n * @example\r\n * // Given a state object and a template\r\n * const state = { userName: \"Alice\", userAge: 30 };\r\n * const template = \"Hello, {{userName}}! You are {{userAge}} years old\";\r\n *\r\n * // Composing the context with simple string replacement will result in:\r\n * // \"Hello, Alice! You are 30 years old.\"\r\n * const contextSimple = composeContext({ state, template });\r\n *\r\n * // Using composeContext with a template function for dynamic template\r\n * const template = ({ state }) => {\r\n * const tone = Math.random() > 0.5 ? \"kind\" : \"rude\";\r\n *   return `Hello, {{userName}}! You are {{userAge}} years old. Be ${tone}`;\r\n * };\r\n * const contextSimple = composeContext({ state, template });\r\n */\r\n\r\nexport const composeContext = ({\r\n    state,\r\n    template,\r\n    templatingEngine,\r\n}: {\r\n    state: State;\r\n    template: TemplateType;\r\n    templatingEngine?: \"handlebars\";\r\n}) => {\r\n  return coreComposeContext({ state, template, templatingEngine });\r\n}\r\n\r\n/**\r\n * Adds a header to a body of text.\r\n *\r\n * This function takes a header string and a body string and returns a new string with the header prepended to the body.\r\n * If the body string is empty, the header is returned as is.\r\n *\r\n * @param {string} header - The header to add to the body.\r\n * @param {string} body - The body to which to add the header.\r\n * @returns {string} The body with the header prepended.\r\n *\r\n * @example\r\n * // Given a header and a body\r\n * const header = \"Header\";\r\n * const body = \"Body\";\r\n *\r\n * // Adding the header to the body will result in:\r\n * // \"Header\\nBody\"\r\n * const text = addHeader(header, body);\r\n */\r\nexport const addHeader = (header: string, body: string) => {\r\n  return coreAddHeader(header, body);\r\n}\r\n\r\n/**\r\n * Generates a string with random user names populated in a template.\r\n *\r\n * This function generates a specified number of random user names and populates placeholders\r\n * in the provided template with these names. Placeholders in the template should follow the format `{{userX}}`\r\n * where `X` is the position of the user (e.g., `{{user1}}`, `{{user2}}`).\r\n *\r\n * @param {string} params.template - The template string containing placeholders for random user names.\r\n * @param {number} params.length - The number of random user names to generate.\r\n * @returns {string} The template string with placeholders replaced by random user names.\r\n *\r\n * @example\r\n * // Given a template and a length\r\n * const template = \"Hello, {{user1}}! Meet {{user2}} and {{user3}}.\";\r\n * const length = 3;\r\n *\r\n * // Composing the random user string will result in:\r\n * // \"Hello, John! Meet Alice and Bob.\"\r\n * const result = composeRandomUser({ template, length });\r\n */\r\nexport const composeRandomUser = (template: string, length: number) => {\r\n  return coreComposeRandomUser(template, length);\r\n};\r\n","import {\r\n  EmbeddingProvider as coreEmbeddingProvider,\r\n  getEmbeddingConfig as coreGetEmbeddingConfig,\r\n  getEmbeddingType as coreGetEmbeddingType,\r\n  getEmbeddingZeroVector as coreGetEmbeddingZeroVector,\r\n  embed as coreEmbed,\r\n} from '@elizaos/core';\r\n\r\nimport { type IAgentRuntime, ModelProviderName } from \"./types.ts\";\r\n\r\nexport const EmbeddingProvider = coreEmbeddingProvider;\r\n\r\nexport type EmbeddingProviderType =\r\n    (typeof EmbeddingProvider)[keyof typeof EmbeddingProvider];\r\n\r\nexport type EmbeddingConfig = {\r\n    readonly dimensions: number;\r\n    readonly model: string;\r\n    readonly provider: EmbeddingProviderType;\r\n};\r\n\r\nexport const getEmbeddingConfig = coreGetEmbeddingConfig;\r\n\r\nexport function getEmbeddingType(runtime: IAgentRuntime): \"local\" | \"remote\" {\r\n  return coreGetEmbeddingType(runtime);\r\n}\r\n\r\nexport function getEmbeddingZeroVector(): number[] {\r\n  return coreGetEmbeddingZeroVector()\r\n}\r\n\r\n\r\n/**\r\n * Gets embeddings from a remote API endpoint.  Falls back to local BGE/384\r\n *\r\n * @param {string} input - The text to generate embeddings for\r\n * @param {EmbeddingOptions} options - Configuration options including:\r\n *   - model: The model name to use\r\n *   - endpoint: Base API endpoint URL\r\n *   - apiKey: Optional API key for authentication\r\n *   - isOllama: Whether this is an Ollama endpoint\r\n *   - dimensions: Desired embedding dimensions\r\n * @param {IAgentRuntime} runtime - The agent runtime context\r\n * @returns {Promise<number[]>} Array of embedding values\r\n * @throws {Error} If the API request fails\r\n */\r\nexport async function embed(runtime: IAgentRuntime, input: string) {\r\n  return coreEmbed(runtime, input);\r\n}\r\n\r\n","import {\r\n  envSchema as coreEnvSchema,\r\n  type EnvConfig as coreEnvConfig,\r\n  validateEnv as coreValidateEnv,\r\n  CharacterSchema as coreCharacterSchema,\r\n  type CharacterConfig as coreCharacterConfig,\r\n  validateCharacterConfig as coreValidateCharacterConfig,\r\n} from '@elizaos/core';\r\n\r\nimport { ModelProviderName } from \"./types\";\r\n\r\nexport const envSchema = coreEnvSchema;\r\n\r\n// Type inference\r\nexport type EnvConfig = coreEnvConfig;\r\n\r\n// Validation function\r\nexport function validateEnv(): EnvConfig {\r\n  return coreValidateEnv();\r\n}\r\n\r\n// Main Character schema\r\nexport const CharacterSchema = coreCharacterSchema;\r\n\r\n// Type inference\r\nexport type CharacterConfig = coreCharacterConfig;\r\n\r\n// Validation function\r\nexport function validateCharacterConfig(json: unknown): CharacterConfig {\r\n  return coreValidateCharacterConfig(json);\r\n}\r\n\r\n","import {\r\n  evaluationTemplate as coreEvaluationTemplate,\r\n  formatEvaluatorNames as coreFormatEvaluatorNames,\r\n  formatEvaluators as coreFormatEvaluators,\r\n  formatEvaluatorExamples as coreFormatEvaluatorExamples,\r\n  formatEvaluatorExampleDescriptions as coreFormatEvaluatorExampleDescriptions,\r\n} from '@elizaos/core';\r\n\r\nimport type { ActionExample, Evaluator } from \"./types.ts\";\r\n\r\n/**\r\n * Template used for the evaluation generateText.\r\n */\r\nexport const evaluationTemplate = coreEvaluationTemplate;\r\n\r\n/**\r\n * Formats the names of evaluators into a comma-separated list, each enclosed in single quotes.\r\n * @param evaluators - An array of evaluator objects.\r\n * @returns A string that concatenates the names of all evaluators, each enclosed in single quotes and separated by commas.\r\n */\r\nexport function formatEvaluatorNames(evaluators: Evaluator[]) {\r\n  return coreFormatEvaluatorNames(evaluators);\r\n}\r\n\r\n/**\r\n * Formats evaluator details into a string, including both the name and description of each evaluator.\r\n * @param evaluators - An array of evaluator objects.\r\n * @returns A string that concatenates the name and description of each evaluator, separated by a colon and a newline character.\r\n */\r\nexport function formatEvaluators(evaluators: Evaluator[]) {\r\n  return coreFormatEvaluators(evaluators);\r\n}\r\n\r\n/**\r\n * Formats evaluator examples into a readable string, replacing placeholders with generated names.\r\n * @param evaluators - An array of evaluator objects, each containing examples to format.\r\n * @returns A string that presents each evaluator example in a structured format, including context, messages, and outcomes, with placeholders replaced by generated names.\r\n */\r\nexport function formatEvaluatorExamples(evaluators: Evaluator[]) {\r\n  return coreFormatEvaluatorExamples(evaluators);\r\n}\r\n\r\n/**\r\n * Generates a string summarizing the descriptions of each evaluator example.\r\n * @param evaluators - An array of evaluator objects, each containing examples.\r\n * @returns A string that summarizes the descriptions for each evaluator example, formatted with the evaluator name, example number, and description.\r\n */\r\nexport function formatEvaluatorExampleDescriptions(evaluators: Evaluator[]) {\r\n  return coreFormatEvaluatorExampleDescriptions(evaluators);\r\n}","import {\r\n  trimTokens as coreTrimTokens,\r\n  generateText as coreGenerateText,\r\n  generateShouldRespond as coreGenerateShouldRespond,\r\n  splitChunks as coreSplitChunks,\r\n  splitText as coreSplitText,\r\n  generateTrueOrFalse as coreGenerateTrueOrFalse,\r\n  generateTextArray as coreGenerateTextArray,\r\n  generateObjectDeprecated as coreGenerateObjectDeprecated,\r\n  generateObjectArray as coreGenerateObjectArray,\r\n  generateMessageResponse as coreGenerateMessageResponse,\r\n  generateImage as coreGenerateImage,\r\n  generateCaption as coreGenerateCaption,\r\n  generateObject as coreGenerateObject,\r\n  handleProvider as coreHandleProvider,\r\n  generateTweetActions as coreGenerateTweetActions,\r\n} from '@elizaos/core';\r\n\r\nimport {\r\n    type Content,\r\n    type IAgentRuntime,\r\n    type IImageDescriptionService,\r\n    type ITextGenerationService,\r\n    ModelClass,\r\n    ModelProviderName,\r\n    ServiceType,\r\n    type ActionResponse,\r\n    // type IVerifiableInferenceAdapter,\r\n    // type VerifiableInferenceOptions,\r\n    // type VerifiableInferenceResult,\r\n    //VerifiableInferenceProvider,\r\n    type TelemetrySettings,\r\n    TokenizerType,\r\n} from \"./types.ts\";\r\nimport type { ZodSchema } from \"zod\";\r\nimport {\r\n    type CoreTool,\r\n    type GenerateObjectResult,\r\n    type StepResult as AIStepResult,\r\n} from \"ai\";\r\n\r\ntype Tool = CoreTool<any, any>;\r\ntype StepResult = AIStepResult<any>;\r\n\r\n// Simplify the types to avoid deep recursion\r\ntype GenerationResult = GenerateObjectResult<unknown>;\r\n\r\n/**\r\n * Base settings for model generation.\r\n */\r\ninterface ModelSettings {\r\n    prompt: string;\r\n    temperature: number;\r\n    maxTokens: number;\r\n    frequencyPenalty: number;\r\n    presencePenalty: number;\r\n    stop?: string[];\r\n    experimental_telemetry?: TelemetrySettings;\r\n}\r\n\r\ninterface ProviderOptions {\r\n    runtime: IAgentRuntime;\r\n    provider: ModelProviderName;\r\n    model: string;\r\n    apiKey: string;\r\n    schema?: ZodSchema;\r\n    schemaName?: string;\r\n    schemaDescription?: string;\r\n    mode?: \"auto\" | \"json\" | \"tool\";\r\n    modelOptions: ModelSettings;\r\n    modelClass: ModelClass;\r\n    context: string;\r\n}\r\n\r\n\r\n/**\r\n * Trims the provided text context to a specified token limit using a tokenizer model and type.\r\n *\r\n * The function dynamically determines the truncation method based on the tokenizer settings\r\n * provided by the runtime. If no tokenizer settings are defined, it defaults to using the\r\n * TikToken truncation method with the \"gpt-4o\" model.\r\n *\r\n * @async\r\n * @function trimTokens\r\n * @param {string} context - The text to be tokenized and trimmed.\r\n * @param {number} maxTokens - The maximum number of tokens allowed after truncation.\r\n * @param {IAgentRuntime} runtime - The runtime interface providing tokenizer settings.\r\n *\r\n * @returns {Promise<string>} A promise that resolves to the trimmed text.\r\n *\r\n * @throws {Error} Throws an error if the runtime settings are invalid or missing required fields.\r\n *\r\n * @example\r\n * const trimmedText = await trimTokens(\"This is an example text\", 50, runtime);\r\n * console.log(trimmedText); // Output will be a truncated version of the input text.\r\n */\r\nexport async function trimTokens(\r\n    context: string,\r\n    maxTokens: number,\r\n    runtime: IAgentRuntime\r\n) {\r\n  return coreTrimTokens(context, maxTokens, runtime);\r\n}\r\n\r\n/**\r\n * Send a message to the model for a text generateText - receive a string back and parse how you'd like\r\n * @param opts - The options for the generateText request.\r\n * @param opts.context The context of the message to be completed.\r\n * @param opts.stop A list of strings to stop the generateText at.\r\n * @param opts.model The model to use for generateText.\r\n * @param opts.frequency_penalty The frequency penalty to apply to the generateText.\r\n * @param opts.presence_penalty The presence penalty to apply to the generateText.\r\n * @param opts.temperature The temperature to apply to the generateText.\r\n * @param opts.max_context_length The maximum length of the context to apply to the generateText.\r\n * @returns The completed message.\r\n */\r\n\r\nexport async function generateText({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n    tools = {},\r\n    onStepFinish,\r\n    maxSteps = 1,\r\n    stop,\r\n    customSystemPrompt,\r\n}: // verifiableInference = process.env.VERIFIABLE_INFERENCE_ENABLED === \"true\",\r\n// verifiableInferenceOptions,\r\n{\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n    tools?: Record<string, Tool>;\r\n    onStepFinish?: (event: StepResult) => Promise<void> | void;\r\n    maxSteps?: number;\r\n    stop?: string[];\r\n    customSystemPrompt?: string;\r\n    // verifiableInference?: boolean;\r\n    // verifiableInferenceAdapter?: IVerifiableInferenceAdapter;\r\n    // verifiableInferenceOptions?: VerifiableInferenceOptions;\r\n}): Promise<string> {\r\n  return coreGenerateText({ runtime, context, modelClass, tools, onStepFinish, maxSteps, stop, customSystemPrompt });\r\n}\r\n\r\n\r\n/**\r\n * Sends a message to the model to determine if it should respond to the given context.\r\n * @param opts - The options for the generateText request\r\n * @param opts.context The context to evaluate for response\r\n * @param opts.stop A list of strings to stop the generateText at\r\n * @param opts.model The model to use for generateText\r\n * @param opts.frequency_penalty The frequency penalty to apply (0.0 to 2.0)\r\n * @param opts.presence_penalty The presence penalty to apply (0.0 to 2.0)\r\n * @param opts.temperature The temperature to control randomness (0.0 to 2.0)\r\n * @param opts.serverUrl The URL of the API server\r\n * @param opts.max_context_length Maximum allowed context length in tokens\r\n * @param opts.max_response_length Maximum allowed response length in tokens\r\n * @returns Promise resolving to \"RESPOND\", \"IGNORE\", \"STOP\" or null\r\n */\r\nexport async function generateShouldRespond({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\r\n  return coreGenerateShouldRespond({ runtime, context, modelClass })\r\n}\r\n\r\n/**\r\n * Splits content into chunks of specified size with optional overlapping bleed sections\r\n * @param content - The text content to split into chunks\r\n * @param chunkSize - The maximum size of each chunk in tokens\r\n * @param bleed - Number of characters to overlap between chunks (default: 100)\r\n * @returns Promise resolving to array of text chunks with bleed sections\r\n */\r\nexport async function splitChunks(\r\n    content: string,\r\n    chunkSize = 1500,\r\n    bleed = 100\r\n): Promise<string[]> {\r\n  return coreSplitChunks(content, chunkSize, bleed);\r\n}\r\n\r\nexport function splitText(\r\n    content: string,\r\n    chunkSize: number,\r\n    bleed: number\r\n): string[] {\r\n  return coreSplitText(content, chunkSize, bleed);\r\n}\r\n\r\n/**\r\n * Sends a message to the model and parses the response as a boolean value\r\n * @param opts - The options for the generateText request\r\n * @param opts.context The context to evaluate for the boolean response\r\n * @param opts.stop A list of strings to stop the generateText at\r\n * @param opts.model The model to use for generateText\r\n * @param opts.frequency_penalty The frequency penalty to apply (0.0 to 2.0)\r\n * @param opts.presence_penalty The presence penalty to apply (0.0 to 2.0)\r\n * @param opts.temperature The temperature to control randomness (0.0 to 2.0)\r\n * @param opts.serverUrl The URL of the API server\r\n * @param opts.max_context_length Maximum allowed context length in tokens\r\n * @param opts.max_response_length Maximum allowed response length in tokens\r\n * @returns Promise resolving to a boolean value parsed from the model's response\r\n */\r\nexport async function generateTrueOrFalse({\r\n    runtime,\r\n    context = \"\",\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<boolean> {\r\n  return coreGenerateTrueOrFalse({ runtime, context, modelClass });\r\n}\r\n\r\n/**\r\n * Send a message to the model and parse the response as a string array\r\n * @param opts - The options for the generateText request\r\n * @param opts.context The context/prompt to send to the model\r\n * @param opts.stop Array of strings that will stop the model's generation if encountered\r\n * @param opts.model The language model to use\r\n * @param opts.frequency_penalty The frequency penalty to apply (0.0 to 2.0)\r\n * @param opts.presence_penalty The presence penalty to apply (0.0 to 2.0)\r\n * @param opts.temperature The temperature to control randomness (0.0 to 2.0)\r\n * @param opts.serverUrl The URL of the API server\r\n * @param opts.token The API token for authentication\r\n * @param opts.max_context_length Maximum allowed context length in tokens\r\n * @param opts.max_response_length Maximum allowed response length in tokens\r\n * @returns Promise resolving to an array of strings parsed from the model's response\r\n */\r\nexport async function generateTextArray({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<string[]> {\r\n  return coreGenerateTextArray({ runtime, context, modelClass });\r\n}\r\n\r\nexport async function generateObjectDeprecated({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<any> {\r\n  return coreGenerateObjectDeprecated({ runtime, context, modelClass });\r\n}\r\n\r\nexport async function generateObjectArray({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<any[]> {\r\n  return coreGenerateObjectArray({ runtime, context, modelClass });\r\n}\r\n\r\n/**\r\n * Send a message to the model for generateText.\r\n * @param opts - The options for the generateText request.\r\n * @param opts.context The context of the message to be completed.\r\n * @param opts.stop A list of strings to stop the generateText at.\r\n * @param opts.model The model to use for generateText.\r\n * @param opts.frequency_penalty The frequency penalty to apply to the generateText.\r\n * @param opts.presence_penalty The presence penalty to apply to the generateText.\r\n * @param opts.temperature The temperature to apply to the generateText.\r\n * @param opts.max_context_length The maximum length of the context to apply to the generateText.\r\n * @returns The completed message.\r\n */\r\nexport async function generateMessageResponse({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<Content> {\r\n  return coreGenerateMessageResponse({ runtime, context, modelClass });\r\n}\r\n\r\nexport const generateImage = async (\r\n    data: {\r\n        prompt: string;\r\n        width: number;\r\n        height: number;\r\n        count?: number;\r\n        negativePrompt?: string;\r\n        numIterations?: number;\r\n        guidanceScale?: number;\r\n        seed?: number;\r\n        modelId?: string;\r\n        jobId?: string;\r\n        stylePreset?: string;\r\n        hideWatermark?: boolean;\r\n        safeMode?: boolean;\r\n        cfgScale?: number;\r\n    },\r\n    runtime: IAgentRuntime\r\n): Promise<{\r\n    success: boolean;\r\n    data?: string[];\r\n    error?: any;\r\n}> => {\r\n  return coreGenerateImage(data, runtime);\r\n}\r\n\r\nexport const generateCaption = async (\r\n    data: { imageUrl: string },\r\n    runtime: IAgentRuntime\r\n): Promise<{\r\n    title: string;\r\n    description: string;\r\n}> => {\r\n  return coreGenerateCaption(data, runtime);\r\n}\r\n\r\n/**\r\n * Configuration options for generating objects with a model.\r\n */\r\nexport interface GenerationOptions {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n    schema?: ZodSchema;\r\n    schemaName?: string;\r\n    schemaDescription?: string;\r\n    stop?: string[];\r\n    mode?: \"auto\" | \"json\" | \"tool\";\r\n    experimental_providerMetadata?: Record<string, unknown>;\r\n    // verifiableInference?: boolean;\r\n    // verifiableInferenceAdapter?: IVerifiableInferenceAdapter;\r\n    // verifiableInferenceOptions?: VerifiableInferenceOptions;\r\n}\r\n\r\n/**\r\n * Generates structured objects from a prompt using specified AI models and configuration options.\r\n *\r\n * @param {GenerationOptions} options - Configuration options for generating objects.\r\n * @returns {Promise<any[]>} - A promise that resolves to an array of generated objects.\r\n * @throws {Error} - Throws an error if the provider is unsupported or if generation fails.\r\n */\r\nexport const generateObject = async ({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n    schema,\r\n    schemaName,\r\n    schemaDescription,\r\n    stop,\r\n    mode = \"json\",\r\n}: // verifiableInference = false,\r\n// verifiableInferenceAdapter,\r\n// verifiableInferenceOptions,\r\nGenerationOptions): Promise<GenerateObjectResult<unknown>> => {\r\n  return coreGenerateObject({ runtime, context, modelClass, schema, schemaName, schemaDescription, stop, mode });\r\n}\r\n\r\n/**\r\n * Handles AI generation based on the specified provider.\r\n *\r\n * @param {ProviderOptions} options - Configuration options specific to the provider.\r\n * @returns {Promise<any[]>} - A promise that resolves to an array of generated objects.\r\n */\r\nexport async function handleProvider(\r\n    options: ProviderOptions\r\n): Promise<GenerationResult> {\r\n  return coreHandleProvider(options)\r\n}\r\n\r\n// doesn't belong here\r\nexport async function generateTweetActions({\r\n    runtime,\r\n    context,\r\n    modelClass,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    context: string;\r\n    modelClass: ModelClass;\r\n}): Promise<ActionResponse | null> {\r\n  return coreGenerateTweetActions({ runtime, context, modelClass });\r\n}","import {\r\n  getGoals as coreGetGoals,\r\n  formatGoalsAsString as coreFormatGoalsAsString,\r\n  updateGoal as coreUpdateGoal,\r\n  createGoal as coreCreateGoal,\r\n} from '@elizaos/core';\r\n\r\nimport type {\r\n    IAgentRuntime,\r\n    Goal,\r\n    Objective,\r\n    UUID,\r\n} from \"./types.ts\";\r\n\r\nexport const getGoals = async ({\r\n    runtime,\r\n    roomId,\r\n    userId,\r\n    onlyInProgress = true,\r\n    count = 5,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    roomId: UUID;\r\n    userId?: UUID;\r\n    onlyInProgress?: boolean;\r\n    count?: number;\r\n}) => {\r\n  return coreGetGoals({ runtime, roomId, userId, onlyInProgress, count })\r\n}\r\n\r\nexport const formatGoalsAsString = ({ goals }: { goals: Goal[] }) => {\r\n  return coreFormatGoalsAsString({ goals });\r\n}\r\n\r\nexport const updateGoal = async ({\r\n    runtime,\r\n    goal,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    goal: Goal;\r\n}) => {\r\n  return coreUpdateGoal({ runtime, goal });\r\n}\r\n\r\nexport const createGoal = async ({\r\n    runtime,\r\n    goal,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    goal: Goal;\r\n}) => {\r\n  return coreCreateGoal({ runtime, goal });\r\n}","import {\r\n  knowledge as coreKnowledge,\r\n  AgentRuntime as coreAgentRuntime,\r\n} from '@elizaos/core';\r\nimport type { AgentRuntime } from \"./runtime.ts\";\r\nimport type { IAgentRuntime, KnowledgeItem, UUID, Memory } from \"./types.ts\";\r\n\r\nasync function get(\r\n    runtime: IAgentRuntime,\r\n    message: Memory\r\n): Promise<KnowledgeItem[]> {\r\n  return coreKnowledge.get(runtime as coreAgentRuntime, message);\r\n}\r\n\r\nasync function set(\r\n    runtime: IAgentRuntime,\r\n    item: KnowledgeItem,\r\n    chunkSize = 512,\r\n    bleed = 20\r\n) {\r\n  return coreKnowledge.set(runtime as coreAgentRuntime, item, chunkSize, bleed);\r\n}\r\n\r\nexport function preprocess(content: string): string {\r\n  return coreKnowledge.preprocess(content);\r\n}\r\n\r\nexport default {\r\n    get,\r\n    set,\r\n    preprocess,\r\n};\r\n","import { elizaLogger as coreLogger } from '@elizaos/core';\r\nimport type { LogFn } from 'pino';\r\n\r\n// Use actual LogFn parameter types to avoid overload mismatch\r\n//type AcceptableArg = string | any[] | Record<string, unknown>\r\ntype LogMethod = (...args: any[]) => void;\r\ntype TupleLogMethod = (args: [string, ...any[]]) => void;\r\n\r\n// Create a function that adapts a TupleLogMethod to a LogMethod\r\nfunction adaptLogMethod(tupleMethod: TupleLogMethod): LogMethod {\r\n  return function(msg: string, ...args: any[]) {\r\n    return tupleMethod([msg, ...args]);\r\n  };\r\n}\r\n\r\nconst logger: Record<\r\n  | 'trace'\r\n  | 'debug'\r\n  | 'success'\r\n  | 'progress'\r\n  | 'log'\r\n  | 'info'\r\n  | 'warn'\r\n  | 'error'\r\n  | 'fatal',\r\n  LogMethod\r\n> & { clear: () => void } = {\r\n  trace: adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.trace.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  debug: adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.debug.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  success: adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.debug.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  progress: adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.debug.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  log: adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.info.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  info:  adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.info.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  warn:  adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.warn.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  error:  adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.error.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  fatal:  adaptLogMethod(([msg, ...rest]) => {\r\n    coreLogger.fatal.apply(coreLogger, [msg, ...rest]);\r\n  }),\r\n  clear: () => coreLogger.clear(''), // call with dummy arg to satisfy \"at least 1 argument\" requirement\r\n};\r\n\r\nexport { logger };\r\nexport const elizaLogger = logger;\r\nexport default logger;\r\n","import { MemoryManager as coreMemoryManager } from '@elizaos/core';\r\nimport type {\r\n    IAgentRuntime,\r\n    IMemoryManager,\r\n    Memory,\r\n    UUID,\r\n} from \"./types.ts\";\r\n\r\nexport class MemoryManager implements IMemoryManager {\r\n    private _mm;\r\n\r\n    /**\r\n     * The AgentRuntime instance associated with this manager.\r\n     */\r\n    runtime: IAgentRuntime;\r\n\r\n    /**\r\n     * The name of the database table this manager operates on.\r\n     */\r\n    tableName: string;\r\n\r\n    /**\r\n     * Constructs a new MemoryManager instance.\r\n     * @param opts Options for the manager.\r\n     * @param opts.tableName The name of the table this manager will operate on.\r\n     * @param opts.runtime The AgentRuntime instance associated with this manager.\r\n     */\r\n    constructor(opts: { tableName: string; runtime: IAgentRuntime }) {\r\n        this._mm = new coreMemoryManager(opts);\r\n        this.runtime = opts.runtime;\r\n        this.tableName = opts.tableName;\r\n    }\r\n\r\n    /**\r\n     * Adds an embedding vector to a memory object if one doesn't already exist.\r\n     * The embedding is generated from the memory's text content using the runtime's\r\n     * embedding model. If the memory has no text content, an error is thrown.\r\n     *\r\n     * @param memory The memory object to add an embedding to\r\n     * @returns The memory object with an embedding vector added\r\n     * @throws Error if the memory content is empty\r\n     */\r\n    async addEmbeddingToMemory(memory: Memory): Promise<Memory> {\r\n      return this._mm.addEmbeddingToMemory(memory);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a list of memories by user IDs, with optional deduplication.\r\n     * @param opts Options including user IDs, count, and uniqueness.\r\n     * @param opts.roomId The room ID to retrieve memories for.\r\n     * @param opts.count The number of memories to retrieve.\r\n     * @param opts.unique Whether to retrieve unique memories only.\r\n     * @returns A Promise resolving to an array of Memory objects.\r\n     */\r\n    async getMemories({\r\n        roomId,\r\n        count = 10,\r\n        unique = true,\r\n        start,\r\n        end,\r\n    }: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]> {\r\n      return this._mm.getMemories({\r\n        roomId,\r\n        count,\r\n        unique,\r\n        start,\r\n        end\r\n      });\r\n    }\r\n\r\n    async getCachedEmbeddings(content: string): Promise<\r\n        {\r\n            embedding: number[];\r\n            levenshtein_score: number;\r\n        }[]\r\n    > {\r\n      return this._mm.getMemories(content)\r\n    }\r\n\r\n    /**\r\n     * Searches for memories similar to a given embedding vector.\r\n     * @param embedding The embedding vector to search with.\r\n     * @param opts Options including match threshold, count, user IDs, and uniqueness.\r\n     * @param opts.match_threshold The similarity threshold for matching memories.\r\n     * @param opts.count The maximum number of memories to retrieve.\r\n     * @param opts.roomId The room ID to retrieve memories for.\r\n     * @param opts.unique Whether to retrieve unique memories only.\r\n     * @returns A Promise resolving to an array of Memory objects that match the embedding.\r\n     */\r\n    async searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        opts: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId: UUID;\r\n            unique?: boolean;\r\n        }\r\n    ): Promise<Memory[]> {\r\n      return this._mm.searchMemoriesByEmbedding(embedding, opts)\r\n    }\r\n\r\n    /**\r\n     * Creates a new memory in the database, with an option to check for similarity before insertion.\r\n     * @param memory The memory object to create.\r\n     * @param unique Whether to check for similarity before insertion.\r\n     * @returns A Promise that resolves when the operation completes.\r\n     */\r\n    async createMemory(memory: Memory, unique = false): Promise<void> {\r\n      return this._mm.createMemory(memory, unique);\r\n    }\r\n\r\n    async getMemoriesByRoomIds(params: { roomIds: UUID[], limit?: number; }): Promise<Memory[]> {\r\n      return this._mm.getMemoriesByRoomIds(params);\r\n    }\r\n\r\n    async getMemoriesByIds(ids: UUID[]): Promise<Memory[]> {\r\n        return this._mm.getMemoriesByIds(ids);\r\n    }\r\n\r\n    async getMemoryById(id: UUID): Promise<Memory | null> {\r\n      return this._mm.getMemoryById(id);\r\n    }\r\n\r\n    /**\r\n     * Removes a memory from the database by its ID.\r\n     * @param memoryId The ID of the memory to remove.\r\n     * @returns A Promise that resolves when the operation completes.\r\n     */\r\n    async removeMemory(memoryId: UUID): Promise<void> {\r\n      return this._mm.removeMemory(memoryId);\r\n    }\r\n\r\n    /**\r\n     * Removes all memories associated with a set of user IDs.\r\n     * @param roomId The room ID to remove memories for.\r\n     * @returns A Promise that resolves when the operation completes.\r\n     */\r\n    async removeAllMemories(roomId: UUID): Promise<void> {\r\n      return this._mm.removeAllMemories(roomId);\r\n    }\r\n\r\n    /**\r\n     * Counts the number of memories associated with a set of user IDs, with an option for uniqueness.\r\n     * @param roomId The room ID to count memories for.\r\n     * @param unique Whether to count unique memories only.\r\n     * @returns A Promise resolving to the count of memories.\r\n     */\r\n    async countMemories(roomId: UUID, unique = true): Promise<number> {\r\n      return this._mm.countMemories(roomId, unique);\r\n    }\r\n}","import {\r\n  messageCompletionFooter as coreMessageCompletionFooter,\r\n  shouldRespondFooter as coreShouldRespondFooter,\r\n  booleanFooter as coreBooleanFooter,\r\n  parseShouldRespondFromText as coreParseShouldRespondFromText,\r\n  stringArrayFooter as coreStringArrayFooter,\r\n  postActionResponseFooter as corePostActionResponseFooter,\r\n  parseJsonArrayFromText as coreParseJsonArrayFromText,\r\n  parseJSONObjectFromText as coreParseJSONObjectFromText,\r\n  extractAttributes as coreExtractAttributes,\r\n  normalizeJsonString as coreNormalizeJsonString,\r\n  cleanJsonResponse as coreCleanJsonResponse,\r\n  parseActionResponseFromText as coreParseActionResponseFromText,\r\n  truncateToCompleteSentence as coreTruncateToCompleteSentence,\r\n} from '@elizaos/core';\r\nimport type { ActionResponse } from \"./types.ts\";\r\n\r\nexport const messageCompletionFooter = coreMessageCompletionFooter;\r\nexport const shouldRespondFooter = coreShouldRespondFooter;\r\n\r\nexport const parseShouldRespondFromText = (\r\n    text: string\r\n): \"RESPOND\" | \"IGNORE\" | \"STOP\" | null => {\r\n  return coreParseShouldRespondFromText(text);\r\n}\r\n\r\nexport const booleanFooter = coreBooleanFooter;\r\n\r\n/**\r\n * Parses a string to determine its boolean equivalent.\r\n *\r\n * Recognized affirmative values: \"YES\", \"Y\", \"TRUE\", \"T\", \"1\", \"ON\", \"ENABLE\".\r\n * Recognized negative values: \"NO\", \"N\", \"FALSE\", \"F\", \"0\", \"OFF\", \"DISABLE\".\r\n *\r\n * @param {string} text - The input text to parse.\r\n * @returns {boolean|null} - Returns `true` for affirmative inputs, `false` for negative inputs, and `null` for unrecognized inputs or null/undefined.\r\n */\r\nexport const parseBooleanFromText = (text: string) => {\r\n}\r\n\r\nexport const stringArrayFooter = coreStringArrayFooter\r\n\r\n/**\r\n * Parses a JSON array from a given text. The function looks for a JSON block wrapped in triple backticks\r\n * with `json` language identifier, and if not found, it searches for an array pattern within the text.\r\n * It then attempts to parse the JSON string into a JavaScript object. If parsing is successful and the result\r\n * is an array, it returns the array; otherwise, it returns null.\r\n *\r\n * @param text - The input text from which to extract and parse the JSON array.\r\n * @returns An array parsed from the JSON string if successful; otherwise, null.\r\n */\r\nexport function parseJsonArrayFromText(text: string) {\r\n  return coreParseJsonArrayFromText(text);\r\n}\r\n\r\n/**\r\n * Parses a JSON object from a given text. The function looks for a JSON block wrapped in triple backticks\r\n * with `json` language identifier, and if not found, it searches for an object pattern within the text.\r\n * It then attempts to parse the JSON string into a JavaScript object. If parsing is successful and the result\r\n * is an object (but not an array), it returns the object; otherwise, it tries to parse an array if the result\r\n * is an array, or returns null if parsing is unsuccessful or the result is neither an object nor an array.\r\n *\r\n * @param text - The input text from which to extract and parse the JSON object.\r\n * @returns An object parsed from the JSON string if successful; otherwise, null or the result of parsing an array.\r\n */\r\nexport function parseJSONObjectFromText(\r\n    text: string\r\n): Record<string, any> | null {\r\n  return coreParseJSONObjectFromText(text);\r\n}\r\n\r\n/**\r\n * Extracts specific attributes (e.g., user, text, action) from a JSON-like string using regex.\r\n * @param response - The cleaned string response to extract attributes from.\r\n * @param attributesToExtract - An array of attribute names to extract.\r\n * @returns An object containing the extracted attributes.\r\n */\r\nexport function extractAttributes(\r\n    response: string,\r\n    attributesToExtract?: string[]\r\n): { [key: string]: string | undefined } {\r\n  return coreExtractAttributes(response, attributesToExtract);\r\n}\r\n\r\n/**\r\n * Normalizes a JSON-like string by correcting formatting issues:\r\n * - Removes extra spaces after '{' and before '}'.\r\n * - Wraps unquoted values in double quotes.\r\n * - Converts single-quoted values to double-quoted.\r\n * - Ensures consistency in key-value formatting.\r\n * - Normalizes mixed adjacent quote pairs.\r\n *\r\n * This is useful for cleaning up improperly formatted JSON strings\r\n * before parsing them into valid JSON.\r\n *\r\n * @param str - The JSON-like string to normalize.\r\n * @returns A properly formatted JSON string.\r\n */\r\n\r\nexport const normalizeJsonString = (str: string) => {\r\n  return coreNormalizeJsonString(str);\r\n}\r\n\r\n/**\r\n * Cleans a JSON-like response string by removing unnecessary markers, line breaks, and extra whitespace.\r\n * This is useful for handling improperly formatted JSON responses from external sources.\r\n *\r\n * @param response - The raw JSON-like string response to clean.\r\n * @returns The cleaned string, ready for parsing or further processing.\r\n */\r\n\r\nexport function cleanJsonResponse(response: string): string {\r\n  return coreCleanJsonResponse(response);\r\n}\r\n\r\nexport const postActionResponseFooter = corePostActionResponseFooter;\r\n\r\nexport const parseActionResponseFromText = (\r\n    text: string\r\n): { actions: ActionResponse } => {\r\n  return coreParseActionResponseFromText(text);\r\n}\r\n\r\n/**\r\n * Truncate text to fit within the character limit, ensuring it ends at a complete sentence.\r\n */\r\nexport function truncateToCompleteSentence(\r\n    text: string,\r\n    maxLength: number\r\n): string {\r\n  return coreTruncateToCompleteSentence(text, maxLength);\r\n}","import {\r\n  getActorDetails as coreGetActorDetails,\r\n  formatActors as coreFormatActors,\r\n  formatMessages as coreFormatMessages,\r\n  formatTimestamp as coreFormatTimestamp,\r\n} from '@elizaos/core';\r\n\r\nimport type {\r\n    IAgentRuntime,\r\n    Actor,\r\n    Content,\r\n    Memory,\r\n    UUID,\r\n} from \"./types.ts\";\r\n\r\n/**\r\n * Get details for a list of actors.\r\n */\r\nexport async function getActorDetails({\r\n    runtime,\r\n    roomId,\r\n}: {\r\n    runtime: IAgentRuntime;\r\n    roomId: UUID;\r\n}) {\r\n  return coreGetActorDetails({ runtime, roomId });\r\n}\r\n\r\n/**\r\n * Format actors into a string\r\n * @param actors - list of actors\r\n * @returns string\r\n */\r\nexport function formatActors({ actors }: { actors: Actor[] }) {\r\n  return coreFormatActors({ actors });\r\n}\r\n\r\n/**\r\n * Format messages into a string\r\n * @param messages - list of messages\r\n * @param actors - list of actors\r\n * @returns string\r\n */\r\nexport const formatMessages = ({\r\n    messages,\r\n    actors,\r\n}: {\r\n    messages: Memory[];\r\n    actors: Actor[];\r\n}) => {\r\n  return coreFormatMessages({ messages, actors });\r\n}\r\n\r\nexport const formatTimestamp = (messageDate: number) => {\r\n  return coreFormatTimestamp(messageDate)\r\n}","import {\r\n  formatPosts as coreFormatPosts,\r\n} from '@elizaos/core';\r\nimport type { Actor, Memory } from \"./types.ts\";\r\n\r\nexport const formatPosts = ({\r\n    messages,\r\n    actors,\r\n    conversationHeader = true,\r\n}: {\r\n    messages: Memory[];\r\n    actors: Actor[];\r\n    conversationHeader?: boolean;\r\n}) => {\r\n  return coreFormatPosts({ messages, actors, conversationHeader })\r\n}\r\n","import {\r\n  getProviders as coreGetProviders,\r\n} from '@elizaos/core';\r\nimport type { IAgentRuntime, State, Memory } from \"./types.ts\";\r\n\r\n/**\r\n * Formats provider outputs into a string which can be injected into the context.\r\n * @param runtime The AgentRuntime object.\r\n * @param message The incoming message object.\r\n * @param state The current state object.\r\n * @returns A string that concatenates the outputs of each provider.\r\n */\r\nexport async function getProviders(\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state?: State\r\n) {\r\n  return coreGetProviders(runtime, message, state);\r\n}","import {\r\n  AgentRuntime as coreAgentRuntime,\r\n} from '@elizaos/core';\r\n\r\nimport {\r\n    type Character,\r\n    type Goal,\r\n    type HandlerCallback,\r\n    type IAgentRuntime,\r\n    type ICacheManager,\r\n    type IDatabaseAdapter,\r\n    type IMemoryManager,\r\n    type IRAGKnowledgeManager,\r\n    // type IVerifiableInferenceAdapter,\r\n    type KnowledgeItem,\r\n    // RAGKnowledgeItem,\r\n    //Media,\r\n    ModelClass,\r\n    ModelProviderName,\r\n    type Plugin,\r\n    type Provider,\r\n    type Adapter,\r\n    type Service,\r\n    type ServiceType,\r\n    type State,\r\n    type UUID,\r\n    type Action,\r\n    type Actor,\r\n    type Evaluator,\r\n    type Memory,\r\n    type DirectoryItem,\r\n    type ClientInstance,\r\n} from \"./types.ts\";\r\n\r\nexport class AgentRuntime implements IAgentRuntime {\r\n  _runtime: coreAgentRuntime;\r\n\r\n    /**\r\n     * Default count for recent messages to be kept in memory.\r\n     * @private\r\n     */\r\n    //readonly #conversationLength = 32 as number;\r\n\r\n    /**\r\n     * The ID of the agent\r\n     */\r\n    agentId: UUID;\r\n    /**\r\n     * The base URL of the server where the agent's requests are processed.\r\n     */\r\n    serverUrl = \"http://localhost:7998\";\r\n\r\n    /**\r\n     * The database adapter used for interacting with the database.\r\n     */\r\n    databaseAdapter: IDatabaseAdapter;\r\n    /**\r\n     * Authentication token used for securing requests.\r\n     */\r\n    token: string | null;\r\n\r\n    /**\r\n     * Custom actions that the agent can perform.\r\n     */\r\n    actions: Action[] = [];\r\n\r\n    /**\r\n     * Evaluators used to assess and guide the agent's responses.\r\n     */\r\n    evaluators: Evaluator[] = [];\r\n\r\n    /**\r\n     * Context providers used to provide context for message generation.\r\n     */\r\n    providers: Provider[] = [];\r\n\r\n    /**\r\n     * Database adapters used to interact with the database.\r\n     */\r\n    adapters: Adapter[] = [];\r\n\r\n    plugins: Plugin[] = [];\r\n\r\n    /**\r\n     * The model to use for generateText.\r\n     */\r\n    modelProvider: ModelProviderName;\r\n\r\n    /**\r\n     * The model to use for generateImage.\r\n     */\r\n    imageModelProvider: ModelProviderName;\r\n\r\n    /**\r\n     * The model to use for describing images.\r\n     */\r\n    imageVisionModelProvider: ModelProviderName;\r\n\r\n    /**\r\n     * Fetch function to use\r\n     * Some environments may not have access to the global fetch function and need a custom fetch override.\r\n     */\r\n    fetch = fetch;\r\n\r\n    /**\r\n     * The character to use for the agent\r\n     */\r\n    character: Character;\r\n\r\n    /**\r\n     * Store messages that are sent and received by the agent.\r\n     */\r\n    messageManager: IMemoryManager;\r\n\r\n    /**\r\n     * Store and recall descriptions of users based on conversations.\r\n     */\r\n    descriptionManager: IMemoryManager;\r\n\r\n    /**\r\n     * Manage the creation and recall of static information (documents, historical game lore, etc)\r\n     */\r\n    loreManager: IMemoryManager;\r\n\r\n    /**\r\n     * Hold large documents that can be referenced\r\n     */\r\n    documentsManager: IMemoryManager;\r\n\r\n    /**\r\n     * Searchable document fragments\r\n     */\r\n    knowledgeManager: IMemoryManager;\r\n\r\n    ragKnowledgeManager: IRAGKnowledgeManager;\r\n\r\n    services: Map<ServiceType, Service> = new Map();\r\n    memoryManagers: Map<string, IMemoryManager> = new Map();\r\n    cacheManager: ICacheManager;\r\n    clients: ClientInstance[] = [];\r\n\r\n    private readonly knowledgeRoot: string;\r\n\r\n\r\n    // verifiableInferenceAdapter?: IVerifiableInferenceAdapter;\r\n\r\n    registerMemoryManager(manager: IMemoryManager): void {\r\n      return this._runtime.registerMemoryManager(manager);\r\n    }\r\n\r\n    getMemoryManager(tableName: string): IMemoryManager | null {\r\n      return this._runtime.getMemoryManager(tableName);\r\n    }\r\n\r\n    getService<T extends Service>(service: ServiceType): T | null {\r\n      return this._runtime.getService(service);\r\n    }\r\n\r\n    async registerService(service: Service): Promise<void> {\r\n      return this._runtime.registerService(service);\r\n    }\r\n\r\n    /**\r\n     * Creates an instance of AgentRuntime.\r\n     * @param opts - The options for configuring the AgentRuntime.\r\n     * @param opts.conversationLength - The number of messages to hold in the recent message cache.\r\n     * @param opts.token - The JWT token, can be a JWT token if outside worker, or an OpenAI token if inside worker.\r\n     * @param opts.serverUrl - The URL of the worker.\r\n     * @param opts.actions - Optional custom actions.\r\n     * @param opts.evaluators - Optional custom evaluators.\r\n     * @param opts.services - Optional custom services.\r\n     * @param opts.memoryManagers - Optional custom memory managers.\r\n     * @param opts.providers - Optional context providers.\r\n     * @param opts.model - The model to use for generateText.\r\n     * @param opts.embeddingModel - The model to use for embedding.\r\n     * @param opts.agentId - Optional ID of the agent.\r\n     * @param opts.databaseAdapter - The database adapter used for interacting with the database.\r\n     * @param opts.fetch - Custom fetch function to use for making requests.\r\n     */\r\n\r\n    constructor(opts: {\r\n        conversationLength?: number; // number of messages to hold in the recent message cache\r\n        agentId?: UUID; // ID of the agent\r\n        character?: Character; // The character to use for the agent\r\n        token: string; // JWT token, can be a JWT token if outside worker, or an OpenAI token if inside worker\r\n        serverUrl?: string; // The URL of the worker\r\n        actions?: Action[]; // Optional custom actions\r\n        evaluators?: Evaluator[]; // Optional custom evaluators\r\n        plugins?: Plugin[];\r\n        providers?: Provider[];\r\n        modelProvider: ModelProviderName;\r\n\r\n        services?: Service[]; // Map of service name to service instance\r\n        managers?: IMemoryManager[]; // Map of table name to memory manager\r\n        databaseAdapter?: IDatabaseAdapter; // The database adapter used for interacting with the database\r\n        fetch?: typeof fetch | unknown;\r\n        speechModelPath?: string;\r\n        cacheManager?: ICacheManager;\r\n        logging?: boolean;\r\n        // verifiableInferenceAdapter?: IVerifiableInferenceAdapter;\r\n    }) {\r\n      this._runtime = new coreAgentRuntime(opts);\r\n      // FIXME: what other properties should we update and maintain references\r\n    }\r\n\r\n    async initialize() {\r\n      this._runtime.initialize();\r\n    }\r\n\r\n    async stop() {\r\n      this._runtime.stop();\r\n    }\r\n\r\n    getSetting(key: string) {\r\n      return this._runtime.getSetting(key);\r\n    }\r\n\r\n    /**\r\n     * Get the number of messages that are kept in the conversation buffer.\r\n     * @returns The number of recent messages to be kept in memory.\r\n     */\r\n    getConversationLength() {\r\n      return this._runtime.getConversationLength();\r\n    }\r\n\r\n    /**\r\n     * Register an action for the agent to perform.\r\n     * @param action The action to register.\r\n     */\r\n    registerAction(action: Action) {\r\n      return this._runtime.registerAction(action);\r\n    }\r\n\r\n    /**\r\n     * Register an evaluator to assess and guide the agent's responses.\r\n     * @param evaluator The evaluator to register.\r\n     */\r\n    registerEvaluator(evaluator: Evaluator) {\r\n      return this._runtime.registerEvaluator(evaluator);\r\n    }\r\n\r\n    /**\r\n     * Register a context provider to provide context for message generation.\r\n     * @param provider The context provider to register.\r\n     */\r\n    registerContextProvider(provider: Provider) {\r\n      return this._runtime.registerContextProvider(provider);\r\n    }\r\n\r\n    /**\r\n     * Register an adapter for the agent to use.\r\n     * @param adapter The adapter to register.\r\n     */\r\n    registerAdapter(adapter: Adapter) {\r\n      return this._runtime.registerAdapter(adapter);\r\n    }\r\n\r\n    /**\r\n     * Process the actions of a message.\r\n     * @param message The message to process.\r\n     * @param content The content of the message to process actions from.\r\n     */\r\n    async processActions(\r\n        message: Memory,\r\n        responses: Memory[],\r\n        state?: State,\r\n        callback?: HandlerCallback,\r\n    ): Promise<void> {\r\n      return this._runtime.processActions(message, responses, state, callback);\r\n    }\r\n\r\n    /**\r\n     * Evaluate the message and state using the registered evaluators.\r\n     * @param message The message to evaluate.\r\n     * @param state The state of the agent.\r\n     * @param didRespond Whether the agent responded to the message.~\r\n     * @param callback The handler callback\r\n     * @returns The results of the evaluation.\r\n     */\r\n    async evaluate(\r\n        message: Memory,\r\n        state: State,\r\n        didRespond?: boolean,\r\n        callback?: HandlerCallback,\r\n    ) {\r\n      return this._runtime.evaluate(message, state, didRespond, callback);\r\n    }\r\n\r\n    /**\r\n     * Ensure the existence of a participant in the room. If the participant does not exist, they are added to the room.\r\n     * @param userId - The user ID to ensure the existence of.\r\n     * @throws An error if the participant cannot be added.\r\n     */\r\n    async ensureParticipantExists(userId: UUID, roomId: UUID) {\r\n      return this._runtime.ensureParticipantExists(userId, roomId);\r\n    }\r\n\r\n    /**\r\n     * Ensure the existence of a user in the database. If the user does not exist, they are added to the database.\r\n     * @param userId - The user ID to ensure the existence of.\r\n     * @param userName - The user name to ensure the existence of.\r\n     * @returns\r\n     */\r\n\r\n    async ensureUserExists(\r\n        userId: UUID,\r\n        userName: string | null,\r\n        name: string | null,\r\n        email?: string | null,\r\n        source?: string | null,\r\n    ) {\r\n      return this._runtime.ensureUserExists(userId, userName, name, email, source);\r\n    }\r\n\r\n    async ensureParticipantInRoom(userId: UUID, roomId: UUID) {\r\n      return this._runtime.ensureParticipantInRoom(userId, roomId);\r\n    }\r\n\r\n    async ensureConnection(\r\n        userId: UUID,\r\n        roomId: UUID,\r\n        userName?: string,\r\n        userScreenName?: string,\r\n        source?: string,\r\n    ) {\r\n      return this._runtime.ensureConnection(userId, roomId, userName, userScreenName, source);\r\n    }\r\n\r\n    /**\r\n     * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user\r\n     * and agent are added as participants. The room ID is returned.\r\n     * @param userId - The user ID to create a room with.\r\n     * @returns The room ID of the room between the agent and the user.\r\n     * @throws An error if the room cannot be created.\r\n     */\r\n    async ensureRoomExists(roomId: UUID) {\r\n      return this._runtime.ensureRoomExists(roomId);\r\n    }\r\n\r\n    /**\r\n     * Compose the state of the agent into an object that can be passed or used for response generation.\r\n     * @param message The message to compose the state from.\r\n     * @returns The state of the agent.\r\n     */\r\n    async composeState(\r\n        message: Memory,\r\n        additionalKeys: { [key: string]: unknown } = {},\r\n    ) {\r\n      return this._runtime.composeState(message, additionalKeys);\r\n    }\r\n\r\n    async updateRecentMessageState(state: State): Promise<State> {\r\n      return this._runtime.updateRecentMessageState(state);\r\n    }\r\n}\r\n","import {\r\n  findNearestEnvFile as coreFindNearestEnvFile,\r\n  configureSettings as coreConfigureSettings,\r\n  loadEnvConfig as coreLoadEnvConfig,\r\n  hasEnvVariable as coreHasEnvVariable,\r\n  settings as coreSettings,\r\n  getEnvVariable as coreGetEnvVariable,\r\n} from '@elizaos/core';\r\nimport type { IAgentRuntime, State, Memory } from \"./types.ts\";\r\n\r\ninterface Settings {\r\n    [key: string]: string | undefined;\r\n}\r\n\r\ninterface NamespacedSettings {\r\n    [namespace: string]: Settings;\r\n}\r\n\r\n/**\r\n * Recursively searches for a .env file starting from the current directory\r\n * and moving up through parent directories (Node.js only)\r\n * @param {string} [startDir=process.cwd()] - Starting directory for the search\r\n * @returns {string|null} Path to the nearest .env file or null if not found\r\n */\r\nexport function findNearestEnvFile(startDir = process.cwd()) {\r\n  return coreFindNearestEnvFile(startDir);\r\n}\r\n\r\n/**\r\n * Configures environment settings for browser usage\r\n * @param {Settings} settings - Object containing environment variables\r\n */\r\nexport function configureSettings(settings: Settings) {\r\n  return coreConfigureSettings(settings);\r\n}\r\n\r\n/**\r\n * Loads environment variables from the nearest .env file in Node.js\r\n * or returns configured settings in browser\r\n * @returns {Settings} Environment variables object\r\n * @throws {Error} If no .env file is found in Node.js environment\r\n */\r\nexport function loadEnvConfig(): Settings {\r\n  return coreLoadEnvConfig()\r\n}\r\n\r\n/**\r\n * Gets a specific environment variable\r\n * @param {string} key - The environment variable key\r\n * @param {string} [defaultValue] - Optional default value if key doesn't exist\r\n * @returns {string|undefined} The environment variable value or default value\r\n */\r\nexport function getEnvVariable(\r\n    key: string,\r\n    defaultValue?: string\r\n): string | undefined {\r\n  return coreGetEnvVariable(key, defaultValue);\r\n}\r\n\r\n/**\r\n * Checks if a specific environment variable exists\r\n * @param {string} key - The environment variable key\r\n * @returns {boolean} True if the environment variable exists\r\n */\r\nexport function hasEnvVariable(key: string): boolean {\r\n  return coreHasEnvVariable(key);\r\n}\r\n\r\n// Initialize settings based on environment\r\nexport const settings: Settings = coreSettings;\r\n\r\nexport default settings;\r\n","import type { Readable } from \"stream\";\r\n\r\n/**\r\n * Represents a UUID string in the format \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\r\n */\r\nexport type UUID = `${string}-${string}-${string}-${string}-${string}`;\r\n\r\n/**\r\n * Represents the content of a message or communication\r\n */\r\nexport interface Content {\r\n    /** The main text content */\r\n    text: string;\r\n\r\n    /** Optional action associated with the message */\r\n    action?: string;\r\n\r\n    /** Optional source/origin of the content */\r\n    source?: string;\r\n\r\n    /** URL of the original message/post (e.g. tweet URL, Discord message link) */\r\n    url?: string;\r\n\r\n    /** UUID of parent message if this is a reply/thread */\r\n    inReplyTo?: UUID;\r\n\r\n    /** Array of media attachments */\r\n    attachments?: Media[];\r\n\r\n    /** Additional dynamic properties */\r\n    [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Example content with associated user for demonstration purposes\r\n */\r\nexport interface ActionExample {\r\n    /** User associated with the example */\r\n    user: string;\r\n\r\n    /** Content of the example */\r\n    content: Content;\r\n}\r\n\r\n/**\r\n * Example conversation content with user ID\r\n */\r\nexport interface ConversationExample {\r\n    /** UUID of user in conversation */\r\n    userId: UUID;\r\n\r\n    /** Content of the conversation */\r\n    content: Content;\r\n}\r\n\r\n/**\r\n * Represents an actor/participant in a conversation\r\n */\r\nexport interface Actor {\r\n    /** Display name */\r\n    name: string;\r\n\r\n    /** Username/handle */\r\n    username: string;\r\n\r\n    /** Additional profile details */\r\n    details: {\r\n        /** Short profile tagline */\r\n        tagline: string;\r\n\r\n        /** Longer profile summary */\r\n        summary: string;\r\n\r\n        /** Favorite quote */\r\n        quote: string;\r\n    };\r\n\r\n    /** Unique identifier */\r\n    id: UUID;\r\n}\r\n\r\n/**\r\n * Represents a single objective within a goal\r\n */\r\nexport interface Objective {\r\n    /** Optional unique identifier */\r\n    id?: string;\r\n\r\n    /** Description of what needs to be achieved */\r\n    description: string;\r\n\r\n    /** Whether objective is completed */\r\n    completed: boolean;\r\n}\r\n\r\n/**\r\n * Status enum for goals\r\n */\r\nexport enum GoalStatus {\r\n    DONE = \"DONE\",\r\n    FAILED = \"FAILED\",\r\n    IN_PROGRESS = \"IN_PROGRESS\",\r\n}\r\n\r\n/**\r\n * Represents a high-level goal composed of objectives\r\n */\r\nexport interface Goal {\r\n    /** Optional unique identifier */\r\n    id?: UUID;\r\n\r\n    /** Room ID where goal exists */\r\n    roomId: UUID;\r\n\r\n    /** User ID of goal owner */\r\n    userId: UUID;\r\n\r\n    /** Name/title of the goal */\r\n    name: string;\r\n\r\n    /** Current status */\r\n    status: GoalStatus;\r\n\r\n    /** Component objectives */\r\n    objectives: Objective[];\r\n}\r\n\r\n/**\r\n * Model size/type classification\r\n */\r\nexport enum ModelClass {\r\n    SMALL = \"small\",\r\n    MEDIUM = \"medium\",\r\n    LARGE = \"large\",\r\n    EMBEDDING = \"embedding\",\r\n    IMAGE = \"image\",\r\n}\r\n\r\n/**\r\n * Model settings\r\n */\r\nexport type ModelSettings = {\r\n    /** Model name */\r\n    name: string;\r\n\r\n    /** Maximum input tokens */\r\n    maxInputTokens: number;\r\n\r\n    /** Maximum output tokens */\r\n    maxOutputTokens: number;\r\n\r\n    /** Optional frequency penalty */\r\n    frequency_penalty?: number;\r\n\r\n    /** Optional presence penalty */\r\n    presence_penalty?: number;\r\n\r\n    /** Optional repetition penalty */\r\n    repetition_penalty?: number;\r\n\r\n    /** Stop sequences */\r\n    stop: string[];\r\n\r\n    /** Temperature setting */\r\n    temperature: number;\r\n\r\n    /** Optional telemetry configuration (experimental) */\r\n    experimental_telemetry?: TelemetrySettings;\r\n};\r\n\r\n/** Image model settings */\r\nexport type ImageModelSettings = {\r\n    name: string;\r\n    steps?: number;\r\n};\r\n\r\n/** Embedding model settings */\r\nexport type EmbeddingModelSettings = {\r\n    name: string;\r\n    dimensions?: number;\r\n};\r\n\r\n/**\r\n * Configuration for an AI model\r\n */\r\nexport type Model = {\r\n    /** Optional API endpoint */\r\n    endpoint?: string;\r\n\r\n    /** Model names by size class */\r\n    model: {\r\n        [ModelClass.SMALL]?: ModelSettings;\r\n        [ModelClass.MEDIUM]?: ModelSettings;\r\n        [ModelClass.LARGE]?: ModelSettings;\r\n        [ModelClass.EMBEDDING]?: EmbeddingModelSettings;\r\n        [ModelClass.IMAGE]?: ImageModelSettings;\r\n    };\r\n};\r\n\r\n/**\r\n * Model configurations by provider\r\n */\r\nexport type Models = {\r\n    [ModelProviderName.OPENAI]: Model;\r\n    [ModelProviderName.ETERNALAI]: Model;\r\n    [ModelProviderName.ANTHROPIC]: Model;\r\n    [ModelProviderName.GROK]: Model;\r\n    [ModelProviderName.GROQ]: Model;\r\n    [ModelProviderName.LLAMACLOUD]: Model;\r\n    [ModelProviderName.TOGETHER]: Model;\r\n    [ModelProviderName.LLAMALOCAL]: Model;\r\n    [ModelProviderName.LMSTUDIO]: Model;\r\n    [ModelProviderName.GOOGLE]: Model;\r\n    [ModelProviderName.MISTRAL]: Model;\r\n    [ModelProviderName.CLAUDE_VERTEX]: Model;\r\n    [ModelProviderName.REDPILL]: Model;\r\n    [ModelProviderName.OPENROUTER]: Model;\r\n    [ModelProviderName.AIMLAPI]: Model;\r\n    [ModelProviderName.OLLAMA]: Model;\r\n    [ModelProviderName.HEURIST]: Model;\r\n    [ModelProviderName.GALADRIEL]: Model;\r\n    [ModelProviderName.FAL]: Model;\r\n    [ModelProviderName.GAIANET]: Model;\r\n    [ModelProviderName.ALI_BAILIAN]: Model;\r\n    [ModelProviderName.VOLENGINE]: Model;\r\n    [ModelProviderName.NANOGPT]: Model;\r\n    [ModelProviderName.HYPERBOLIC]: Model;\r\n    [ModelProviderName.VENICE]: Model;\r\n    [ModelProviderName.NVIDIA]: Model;\r\n    [ModelProviderName.NINETEEN_AI]: Model;\r\n    [ModelProviderName.AKASH_CHAT_API]: Model;\r\n    [ModelProviderName.LIVEPEER]: Model;\r\n    [ModelProviderName.DEEPSEEK]: Model;\r\n    [ModelProviderName.INFERA]: Model;\r\n    [ModelProviderName.BEDROCK]: Model;\r\n    [ModelProviderName.ATOMA]: Model;\r\n    [ModelProviderName.SECRETAI]: Model;\r\n    [ModelProviderName.NEARAI]: Model;\r\n    [ModelProviderName.KLUSTERAI]: Model;\r\n    [ModelProviderName.MEM0]: Model;\r\n};\r\n\r\n/**\r\n * Available model providers\r\n */\r\nexport enum ModelProviderName {\r\n    OPENAI = \"openai\",\r\n    ETERNALAI = \"eternalai\",\r\n    ANTHROPIC = \"anthropic\",\r\n    GROK = \"grok\",\r\n    GROQ = \"groq\",\r\n    LLAMACLOUD = \"llama_cloud\",\r\n    TOGETHER = \"together\",\r\n    LLAMALOCAL = \"llama_local\",\r\n    LMSTUDIO = \"lmstudio\",\r\n    GOOGLE = \"google\",\r\n    MISTRAL = \"mistral\",\r\n    CLAUDE_VERTEX = \"claude_vertex\",\r\n    REDPILL = \"redpill\",\r\n    OPENROUTER = \"openrouter\",\r\n    AIMLAPI = \"aimlapi\",\r\n    OLLAMA = \"ollama\",\r\n    HEURIST = \"heurist\",\r\n    GALADRIEL = \"galadriel\",\r\n    FAL = \"falai\",\r\n    GAIANET = \"gaianet\",\r\n    ALI_BAILIAN = \"ali_bailian\",\r\n    VOLENGINE = \"volengine\",\r\n    NANOGPT = \"nanogpt\",\r\n    HYPERBOLIC = \"hyperbolic\",\r\n    VENICE = \"venice\",\r\n    NVIDIA = \"nvidia\",\r\n    NINETEEN_AI = \"nineteen_ai\",\r\n    AKASH_CHAT_API = \"akash_chat_api\",\r\n    LIVEPEER = \"livepeer\",\r\n    LETZAI = \"letzai\",\r\n    DEEPSEEK = \"deepseek\",\r\n    INFERA = \"infera\",\r\n    BEDROCK = \"bedrock\",\r\n    ATOMA = \"atoma\",\r\n    SECRETAI = \"secret_ai\",\r\n    NEARAI = \"nearai\",\r\n    KLUSTERAI = \"kluster_ai\",\r\n    MEM0 = \"mem0\",\r\n}\r\n\r\n/**\r\n * Represents the current state/context of a conversation\r\n */\r\nexport interface State {\r\n    /** ID of user who sent current message */\r\n    userId?: UUID;\r\n\r\n    /** ID of agent in conversation */\r\n    agentId?: UUID;\r\n\r\n    /** Agent's biography */\r\n    bio: string;\r\n\r\n    /** Agent's background lore */\r\n    lore: string;\r\n\r\n    /** Message handling directions */\r\n    messageDirections: string;\r\n\r\n    /** Post handling directions */\r\n    postDirections: string;\r\n\r\n    /** Current room/conversation ID */\r\n    roomId: UUID;\r\n\r\n    /** Optional agent name */\r\n    agentName?: string;\r\n\r\n    /** Optional message sender name */\r\n    senderName?: string;\r\n\r\n    /** String representation of conversation actors */\r\n    actors: string;\r\n\r\n    /** Optional array of actor objects */\r\n    actorsData?: Actor[];\r\n\r\n    /** Optional string representation of goals */\r\n    goals?: string;\r\n\r\n    /** Optional array of goal objects */\r\n    goalsData?: Goal[];\r\n\r\n    /** Recent message history as string */\r\n    recentMessages: string;\r\n\r\n    /** Recent message objects */\r\n    recentMessagesData: Memory[];\r\n\r\n    /** Optional valid action names */\r\n    actionNames?: string;\r\n\r\n    /** Optional action descriptions */\r\n    actions?: string;\r\n\r\n    /** Optional action objects */\r\n    actionsData?: Action[];\r\n\r\n    /** Optional action examples */\r\n    actionExamples?: string;\r\n\r\n    /** Optional provider descriptions */\r\n    providers?: string;\r\n\r\n    /** Optional response content */\r\n    responseData?: Content;\r\n\r\n    /** Optional recent interaction objects */\r\n    recentInteractionsData?: Memory[];\r\n\r\n    /** Optional recent interactions string */\r\n    recentInteractions?: string;\r\n\r\n    /** Optional formatted conversation */\r\n    formattedConversation?: string;\r\n\r\n    /** Optional formatted knowledge */\r\n    knowledge?: string;\r\n    /** Optional knowledge data */\r\n    knowledgeData?: KnowledgeItem[];\r\n    /** Optional knowledge data */\r\n    ragKnowledgeData?: RAGKnowledgeItem[];\r\n\r\n    /** Additional dynamic properties */\r\n    [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * Represents a stored memory/message\r\n */\r\nexport interface Memory {\r\n    /** Optional unique identifier */\r\n    id?: UUID;\r\n\r\n    /** Associated user ID */\r\n    userId: UUID;\r\n\r\n    /** Associated agent ID */\r\n    agentId: UUID;\r\n\r\n    /** Optional creation timestamp */\r\n    createdAt?: number;\r\n\r\n    /** Memory content */\r\n    content: Content;\r\n\r\n    /** Optional embedding vector */\r\n    embedding?: number[];\r\n\r\n    /** Associated room ID */\r\n    roomId: UUID;\r\n\r\n    /** Whether memory is unique */\r\n    unique?: boolean;\r\n\r\n    /** Embedding similarity score */\r\n    similarity?: number;\r\n}\r\n\r\n/**\r\n * Example message for demonstration\r\n */\r\nexport interface MessageExample {\r\n    /** Associated user */\r\n    user: string;\r\n\r\n    /** Message content */\r\n    content: Content;\r\n}\r\n\r\n/**\r\n * Handler function type for processing messages\r\n */\r\nexport type Handler = (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state?: State,\r\n    options?: { [key: string]: unknown },\r\n    callback?: HandlerCallback,\r\n) => Promise<unknown>;\r\n\r\n/**\r\n * Callback function type for handlers\r\n */\r\nexport type HandlerCallback = (\r\n    response: Content,\r\n    files?: any,\r\n) => Promise<Memory[]>;\r\n\r\n/**\r\n * Validator function type for actions/evaluators\r\n */\r\nexport type Validator = (\r\n    runtime: IAgentRuntime,\r\n    message: Memory,\r\n    state?: State,\r\n) => Promise<boolean>;\r\n\r\n/**\r\n * Represents an action the agent can perform\r\n */\r\nexport interface Action {\r\n    /** Similar action descriptions */\r\n    similes: string[];\r\n\r\n    /** Detailed description */\r\n    description: string;\r\n\r\n    /** Example usages */\r\n    examples: ActionExample[][];\r\n\r\n    /** Handler function */\r\n    handler: Handler;\r\n\r\n    /** Action name */\r\n    name: string;\r\n\r\n    /** Validation function */\r\n    validate: Validator;\r\n\r\n    /** Whether to suppress the initial message when this action is used */\r\n    suppressInitialMessage?: boolean;\r\n}\r\n\r\n/**\r\n * Example for evaluating agent behavior\r\n */\r\nexport interface EvaluationExample {\r\n    /** Evaluation context */\r\n    context: string;\r\n\r\n    /** Example messages */\r\n    messages: Array<ActionExample>;\r\n\r\n    /** Expected outcome */\r\n    outcome: string;\r\n}\r\n\r\n/**\r\n * Evaluator for assessing agent responses\r\n */\r\nexport interface Evaluator {\r\n    /** Whether to always run */\r\n    alwaysRun?: boolean;\r\n\r\n    /** Detailed description */\r\n    description: string;\r\n\r\n    /** Similar evaluator descriptions */\r\n    similes: string[];\r\n\r\n    /** Example evaluations */\r\n    examples: EvaluationExample[];\r\n\r\n    /** Handler function */\r\n    handler: Handler;\r\n\r\n    /** Evaluator name */\r\n    name: string;\r\n\r\n    /** Validation function */\r\n    validate: Validator;\r\n}\r\n\r\n/**\r\n * Provider for external data/services\r\n */\r\nexport interface Provider {\r\n    /** Data retrieval function */\r\n    get: (\r\n        runtime: IAgentRuntime,\r\n        message: Memory,\r\n        state?: State,\r\n    ) => Promise<any>;\r\n}\r\n\r\n/**\r\n * Represents a relationship between users\r\n */\r\nexport interface Relationship {\r\n    /** Unique identifier */\r\n    id: UUID;\r\n\r\n    /** First user ID */\r\n    userA: UUID;\r\n\r\n    /** Second user ID */\r\n    userB: UUID;\r\n\r\n    /** Primary user ID */\r\n    userId: UUID;\r\n\r\n    /** Associated room ID */\r\n    roomId: UUID;\r\n\r\n    /** Relationship status */\r\n    status: string;\r\n\r\n    /** Optional creation timestamp */\r\n    createdAt?: string;\r\n}\r\n\r\n/**\r\n * Represents a user account\r\n */\r\nexport interface Account {\r\n    /** Unique identifier */\r\n    id: UUID;\r\n\r\n    /** Display name */\r\n    name: string;\r\n\r\n    /** Username */\r\n    username: string;\r\n\r\n    /** Optional additional details */\r\n    details?: { [key: string]: any };\r\n\r\n    /** Optional email */\r\n    email?: string;\r\n\r\n    /** Optional avatar URL */\r\n    avatarUrl?: string;\r\n}\r\n\r\n/**\r\n * Room participant with account details\r\n */\r\nexport interface Participant {\r\n    /** Unique identifier */\r\n    id: UUID;\r\n\r\n    /** Associated account */\r\n    account: Account;\r\n}\r\n\r\n/**\r\n * Represents a conversation room\r\n */\r\nexport interface Room {\r\n    /** Unique identifier */\r\n    id: UUID;\r\n\r\n    /** Room participants */\r\n    participants: Participant[];\r\n}\r\n\r\n/**\r\n * Represents a media attachment\r\n */\r\nexport type Media = {\r\n    /** Unique identifier */\r\n    id: string;\r\n\r\n    /** Media URL */\r\n    url: string;\r\n\r\n    /** Media title */\r\n    title: string;\r\n\r\n    /** Media source */\r\n    source: string;\r\n\r\n    /** Media description */\r\n    description: string;\r\n\r\n    /** Text content */\r\n    text: string;\r\n\r\n    /** Content type */\r\n    contentType?: string;\r\n};\r\n\r\n/**\r\n * Client instance\r\n */\r\nexport type ClientInstance = {\r\n    /** Client name */\r\n    // name: string;\r\n\r\n    /** Stop client connection */\r\n    stop: (runtime: IAgentRuntime) => Promise<unknown>;\r\n};\r\n\r\n/**\r\n * Client interface for platform connections\r\n */\r\nexport type Client = {\r\n    /** Client name */\r\n    name: string;\r\n\r\n    /** Client configuration */\r\n    config?: { [key: string]: any };\r\n\r\n    /** Start client connection */\r\n    start: (runtime: IAgentRuntime) => Promise<ClientInstance>;\r\n};\r\n\r\n/**\r\n * Database adapter initialization\r\n */\r\nexport type Adapter = {\r\n    /** Initialize the adapter */\r\n    init: (runtime: IAgentRuntime) => IDatabaseAdapter & IDatabaseCacheAdapter;\r\n};\r\n\r\n/**\r\n * Plugin for extending agent functionality\r\n */\r\nexport type Plugin = {\r\n    /** Plugin name */\r\n    name: string;\r\n\r\n    /** Plugin npm name */\r\n    npmName?: string;\r\n\r\n    /** Plugin configuration */\r\n    config?: { [key: string]: any };\r\n\r\n    /** Plugin description */\r\n    description: string;\r\n\r\n    /** Optional actions */\r\n    actions?: Action[];\r\n\r\n    /** Optional providers */\r\n    providers?: Provider[];\r\n\r\n    /** Optional evaluators */\r\n    evaluators?: Evaluator[];\r\n\r\n    /** Optional services */\r\n    services?: Service[];\r\n\r\n    /** Optional clients */\r\n    clients?: Client[];\r\n\r\n    /** Optional adapters */\r\n    adapters?: Adapter[];\r\n\r\n    /** Optional post character processor handler */\r\n    handlePostCharacterLoaded?: (char: Character) => Promise<Character>;\r\n};\r\n\r\nexport interface IAgentConfig {\r\n    [key: string]: string;\r\n}\r\n\r\nexport type TelemetrySettings = {\r\n    /**\r\n     * Enable or disable telemetry. Disabled by default while experimental.\r\n     */\r\n    isEnabled?: boolean;\r\n    /**\r\n     * Enable or disable input recording. Enabled by default.\r\n     *\r\n     * You might want to disable input recording to avoid recording sensitive\r\n     * information, to reduce data transfers, or to increase performance.\r\n     */\r\n    recordInputs?: boolean;\r\n    /**\r\n     * Enable or disable output recording. Enabled by default.\r\n     *\r\n     * You might want to disable output recording to avoid recording sensitive\r\n     * information, to reduce data transfers, or to increase performance.\r\n     */\r\n    recordOutputs?: boolean;\r\n    /**\r\n     * Identifier for this function. Used to group telemetry data by function.\r\n     */\r\n    functionId?: string;\r\n};\r\n\r\nexport interface ModelConfiguration {\r\n    temperature?: number;\r\n    maxOutputTokens?: number;\r\n    frequency_penalty?: number;\r\n    presence_penalty?: number;\r\n    maxInputTokens?: number;\r\n    experimental_telemetry?: TelemetrySettings;\r\n}\r\n\r\nexport type TemplateType = string | ((options: { state: State }) => string);\r\n\r\n/**\r\n * Configuration for an agent character\r\n */\r\nexport type Character = {\r\n    /** Optional unique identifier */\r\n    id?: UUID;\r\n\r\n    /** Character name */\r\n    name: string;\r\n\r\n    /** Optional username */\r\n    username?: string;\r\n\r\n    /** Optional email */\r\n    email?: string;\r\n\r\n    /** Optional system prompt */\r\n    system?: string;\r\n\r\n    /** Model provider to use */\r\n    modelProvider: ModelProviderName;\r\n\r\n    /** Image model provider to use, if different from modelProvider */\r\n    imageModelProvider?: ModelProviderName;\r\n\r\n    /** Image Vision model provider to use, if different from modelProvider */\r\n    imageVisionModelProvider?: ModelProviderName;\r\n\r\n    /** Optional model endpoint override */\r\n    modelEndpointOverride?: string;\r\n\r\n    /** Optional prompt templates */\r\n    templates?: {\r\n        goalsTemplate?: TemplateType;\r\n        factsTemplate?: TemplateType;\r\n        messageHandlerTemplate?: TemplateType;\r\n        shouldRespondTemplate?: TemplateType;\r\n        continueMessageHandlerTemplate?: TemplateType;\r\n        evaluationTemplate?: TemplateType;\r\n        twitterSearchTemplate?: TemplateType;\r\n        twitterActionTemplate?: TemplateType;\r\n        twitterPostTemplate?: TemplateType;\r\n        twitterMessageHandlerTemplate?: TemplateType;\r\n        twitterShouldRespondTemplate?: TemplateType;\r\n        twitterVoiceHandlerTemplate?: TemplateType;\r\n        instagramPostTemplate?: TemplateType;\r\n        instagramMessageHandlerTemplate?: TemplateType;\r\n        instagramShouldRespondTemplate?: TemplateType;\r\n        farcasterPostTemplate?: TemplateType;\r\n        lensPostTemplate?: TemplateType;\r\n        farcasterMessageHandlerTemplate?: TemplateType;\r\n        lensMessageHandlerTemplate?: TemplateType;\r\n        farcasterShouldRespondTemplate?: TemplateType;\r\n        lensShouldRespondTemplate?: TemplateType;\r\n        telegramMessageHandlerTemplate?: TemplateType;\r\n        telegramShouldRespondTemplate?: TemplateType;\r\n        telegramAutoPostTemplate?: string;\r\n        telegramPinnedMessageTemplate?: string;\r\n        discordAutoPostTemplate?: string;\r\n        discordAnnouncementHypeTemplate?: string;\r\n        discordVoiceHandlerTemplate?: TemplateType;\r\n        discordShouldRespondTemplate?: TemplateType;\r\n        discordMessageHandlerTemplate?: TemplateType;\r\n        slackMessageHandlerTemplate?: TemplateType;\r\n        slackShouldRespondTemplate?: TemplateType;\r\n        jeeterPostTemplate?: string;\r\n        jeeterSearchTemplate?: string;\r\n        jeeterInteractionTemplate?: string;\r\n        jeeterMessageHandlerTemplate?: string;\r\n        jeeterShouldRespondTemplate?: string;\r\n        devaPostTemplate?: string;\r\n    };\r\n\r\n    /** Character biography */\r\n    bio: string | string[];\r\n\r\n    /** Character background lore */\r\n    lore: string[];\r\n\r\n    /** Example messages */\r\n    messageExamples: MessageExample[][];\r\n\r\n    /** Example posts */\r\n    postExamples: string[];\r\n\r\n    /** Known topics */\r\n    topics: string[];\r\n\r\n    /** Character traits */\r\n    adjectives: string[];\r\n\r\n    /** Optional knowledge base */\r\n    knowledge?: (string | { path: string; shared?: boolean } | { directory: string; shared?: boolean })[];\r\n\r\n    /** Available plugins */\r\n    plugins: Plugin[];\r\n\r\n    /** Character Processor Plugins */\r\n    postProcessors?: Pick<Plugin, 'name' | 'description' | 'handlePostCharacterLoaded'>[];\r\n\r\n    /** Optional configuration */\r\n    settings?: {\r\n        secrets?: { [key: string]: string };\r\n        intiface?: boolean;\r\n        imageSettings?: {\r\n            steps?: number;\r\n            width?: number;\r\n            height?: number;\r\n            cfgScale?: number;\r\n            negativePrompt?: string;\r\n            numIterations?: number;\r\n            guidanceScale?: number;\r\n            seed?: number;\r\n            modelId?: string;\r\n            jobId?: string;\r\n            count?: number;\r\n            stylePreset?: string;\r\n            hideWatermark?: boolean;\r\n            safeMode?: boolean;\r\n        };\r\n        voice?: {\r\n            model?: string; // For VITS\r\n            url?: string; // Legacy VITS support\r\n            elevenlabs?: {\r\n                // New structured ElevenLabs config\r\n                voiceId: string;\r\n                model?: string;\r\n                stability?: string;\r\n                similarityBoost?: string;\r\n                style?: string;\r\n                useSpeakerBoost?: string;\r\n            };\r\n        };\r\n        model?: string;\r\n        modelConfig?: ModelConfiguration;\r\n        embeddingModel?: string;\r\n        chains?: {\r\n            evm?: any[];\r\n            solana?: any[];\r\n            [key: string]: any[];\r\n        };\r\n        transcription?: TranscriptionProvider;\r\n        ragKnowledge?: boolean;\r\n    };\r\n\r\n    /** Optional client-specific config */\r\n    clientConfig?: {\r\n        discord?: {\r\n            shouldIgnoreBotMessages?: boolean;\r\n            shouldIgnoreDirectMessages?: boolean;\r\n            shouldRespondOnlyToMentions?: boolean;\r\n            messageSimilarityThreshold?: number;\r\n            isPartOfTeam?: boolean;\r\n            teamAgentIds?: string[];\r\n            teamLeaderId?: string;\r\n            teamMemberInterestKeywords?: string[];\r\n            allowedChannelIds?: string[];\r\n            autoPost?: {\r\n                enabled?: boolean;\r\n                monitorTime?: number;\r\n                inactivityThreshold?: number;\r\n                mainChannelId?: string;\r\n                announcementChannelIds?: string[];\r\n                minTimeBetweenPosts?: number;\r\n            };\r\n        };\r\n        telegram?: {\r\n            shouldIgnoreBotMessages?: boolean;\r\n            shouldIgnoreDirectMessages?: boolean;\r\n            shouldRespondOnlyToMentions?: boolean;\r\n            shouldOnlyJoinInAllowedGroups?: boolean;\r\n            allowedGroupIds?: string[];\r\n            messageSimilarityThreshold?: number;\r\n            isPartOfTeam?: boolean;\r\n            teamAgentIds?: string[];\r\n            teamLeaderId?: string;\r\n            teamMemberInterestKeywords?: string[];\r\n            autoPost?: {\r\n                enabled?: boolean;\r\n                monitorTime?: number;\r\n                inactivityThreshold?: number;\r\n                mainChannelId?: string;\r\n                pinnedMessagesGroups?: string[];\r\n                minTimeBetweenPosts?: number;\r\n            };\r\n        };\r\n        slack?: {\r\n            shouldIgnoreBotMessages?: boolean;\r\n            shouldIgnoreDirectMessages?: boolean;\r\n        };\r\n        gitbook?: {\r\n            keywords?: {\r\n                projectTerms?: string[];\r\n                generalQueries?: string[];\r\n            };\r\n            documentTriggers?: string[];\r\n        };\r\n    };\r\n\r\n    /** Writing style guides */\r\n    style: {\r\n        all: string[];\r\n        chat: string[];\r\n        post: string[];\r\n    };\r\n\r\n    /** Optional Twitter profile */\r\n    twitterProfile?: {\r\n        id: string;\r\n        username: string;\r\n        screenName: string;\r\n        bio: string;\r\n        nicknames?: string[];\r\n    };\r\n\r\n    /** Optional Instagram profile */\r\n    instagramProfile?: {\r\n        id: string;\r\n        username: string;\r\n        bio: string;\r\n        nicknames?: string[];\r\n    };\r\n\r\n    /** Optional SimsAI profile */\r\n    simsaiProfile?: {\r\n        id: string;\r\n        username: string;\r\n        screenName: string;\r\n        bio: string;\r\n    };\r\n\r\n    /** Optional NFT prompt */\r\n    nft?: {\r\n        prompt: string;\r\n    };\r\n\r\n    /**Optinal Parent characters to inherit information from */\r\n    extends?: string[];\r\n\r\n    twitterSpaces?: TwitterSpaceDecisionOptions;\r\n};\r\n\r\nexport interface TwitterSpaceDecisionOptions {\r\n    maxSpeakers?: number;\r\n    topics?: string[];\r\n    typicalDurationMinutes?: number;\r\n    idleKickTimeoutMs?: number;\r\n    minIntervalBetweenSpacesMinutes?: number;\r\n    businessHoursOnly?: boolean;\r\n    randomChance?: number;\r\n    enableIdleMonitor?: boolean;\r\n    enableSttTts?: boolean;\r\n    enableRecording?: boolean;\r\n    voiceId?: string;\r\n    sttLanguage?: string;\r\n    speakerMaxDurationMs?: number;\r\n}\r\n\r\n/**\r\n * Interface for database operations\r\n */\r\nexport interface IDatabaseAdapter {\r\n    /** Database instance */\r\n    db: any;\r\n\r\n    /** Optional initialization */\r\n    init(): Promise<void>;\r\n\r\n    /** Close database connection */\r\n    close(): Promise<void>;\r\n\r\n    /** Get account by ID */\r\n    getAccountById(userId: UUID): Promise<Account | null>;\r\n\r\n    /** Create new account */\r\n    createAccount(account: Account): Promise<boolean>;\r\n\r\n    /** Get memories matching criteria */\r\n    getMemories(params: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        tableName: string;\r\n        agentId: UUID;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]>;\r\n\r\n    getMemoryById(id: UUID): Promise<Memory | null>;\r\n\r\n    getMemoriesByIds(ids: UUID[], tableName?: string): Promise<Memory[]>;\r\n\r\n    getMemoriesByRoomIds(params: {\r\n        tableName: string;\r\n        agentId: UUID;\r\n        roomIds: UUID[];\r\n        limit?: number;\r\n    }): Promise<Memory[]>;\r\n\r\n    getCachedEmbeddings(params: {\r\n        query_table_name: string;\r\n        query_threshold: number;\r\n        query_input: string;\r\n        query_field_name: string;\r\n        query_field_sub_name: string;\r\n        query_match_count: number;\r\n    }): Promise<{ embedding: number[]; levenshtein_score: number }[]>;\r\n\r\n    log(params: {\r\n        body: { [key: string]: unknown };\r\n        userId: UUID;\r\n        roomId: UUID;\r\n        type: string;\r\n    }): Promise<void>;\r\n\r\n    getActorDetails(params: { roomId: UUID }): Promise<Actor[]>;\r\n\r\n    searchMemories(params: {\r\n        tableName: string;\r\n        agentId: UUID;\r\n        roomId: UUID;\r\n        embedding: number[];\r\n        match_threshold: number;\r\n        match_count: number;\r\n        unique: boolean;\r\n    }): Promise<Memory[]>;\r\n\r\n    updateGoalStatus(params: {\r\n        goalId: UUID;\r\n        status: GoalStatus;\r\n    }): Promise<void>;\r\n\r\n    searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        params: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId?: UUID;\r\n            agentId?: UUID;\r\n            unique?: boolean;\r\n            tableName: string;\r\n        },\r\n    ): Promise<Memory[]>;\r\n\r\n    createMemory(\r\n        memory: Memory,\r\n        tableName: string,\r\n        unique?: boolean,\r\n    ): Promise<void>;\r\n\r\n    removeMemory(memoryId: UUID, tableName: string): Promise<void>;\r\n\r\n    removeAllMemories(roomId: UUID, tableName: string): Promise<void>;\r\n\r\n    countMemories(\r\n        roomId: UUID,\r\n        unique?: boolean,\r\n        tableName?: string,\r\n    ): Promise<number>;\r\n\r\n    getGoals(params: {\r\n        agentId: UUID;\r\n        roomId: UUID;\r\n        userId?: UUID | null;\r\n        onlyInProgress?: boolean;\r\n        count?: number;\r\n    }): Promise<Goal[]>;\r\n\r\n    updateGoal(goal: Goal): Promise<void>;\r\n\r\n    createGoal(goal: Goal): Promise<void>;\r\n\r\n    removeGoal(goalId: UUID): Promise<void>;\r\n\r\n    removeAllGoals(roomId: UUID): Promise<void>;\r\n\r\n    getRoom(roomId: UUID): Promise<UUID | null>;\r\n\r\n    createRoom(roomId?: UUID): Promise<UUID>;\r\n\r\n    removeRoom(roomId: UUID): Promise<void>;\r\n\r\n    getRoomsForParticipant(userId: UUID): Promise<UUID[]>;\r\n\r\n    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;\r\n\r\n    addParticipant(userId: UUID, roomId: UUID): Promise<boolean>;\r\n\r\n    removeParticipant(userId: UUID, roomId: UUID): Promise<boolean>;\r\n\r\n    getParticipantsForAccount(userId: UUID): Promise<Participant[]>;\r\n\r\n    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;\r\n\r\n    getParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n    ): Promise<\"FOLLOWED\" | \"MUTED\" | null>;\r\n\r\n    setParticipantUserState(\r\n        roomId: UUID,\r\n        userId: UUID,\r\n        state: \"FOLLOWED\" | \"MUTED\" | null,\r\n    ): Promise<void>;\r\n\r\n    createRelationship(params: { userA: UUID; userB: UUID }): Promise<boolean>;\r\n\r\n    getRelationship(params: {\r\n        userA: UUID;\r\n        userB: UUID;\r\n    }): Promise<Relationship | null>;\r\n\r\n    getRelationships(params: { userId: UUID }): Promise<Relationship[]>;\r\n\r\n    getKnowledge(params: {\r\n        id?: UUID;\r\n        agentId: UUID;\r\n        limit?: number;\r\n        query?: string;\r\n        conversationContext?: string;\r\n    }): Promise<RAGKnowledgeItem[]>;\r\n\r\n    searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array;\r\n        match_threshold: number;\r\n        match_count: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]>;\r\n\r\n    createKnowledge(knowledge: RAGKnowledgeItem): Promise<void>;\r\n    removeKnowledge(id: UUID): Promise<void>;\r\n    clearKnowledge(agentId: UUID, shared?: boolean): Promise<void>;\r\n}\r\n\r\nexport interface IDatabaseCacheAdapter {\r\n    getCache(params: {\r\n        agentId: UUID;\r\n        key: string;\r\n    }): Promise<string | undefined>;\r\n\r\n    setCache(params: {\r\n        agentId: UUID;\r\n        key: string;\r\n        value: string;\r\n    }): Promise<boolean>;\r\n\r\n    deleteCache(params: { agentId: UUID; key: string }): Promise<boolean>;\r\n}\r\n\r\nexport interface IMemoryManager {\r\n    runtime: IAgentRuntime;\r\n    tableName: string;\r\n    constructor: Function;\r\n\r\n    addEmbeddingToMemory(memory: Memory): Promise<Memory>;\r\n\r\n    getMemories(opts: {\r\n        roomId: UUID;\r\n        count?: number;\r\n        unique?: boolean;\r\n        start?: number;\r\n        end?: number;\r\n    }): Promise<Memory[]>;\r\n\r\n    getCachedEmbeddings(\r\n        content: string,\r\n    ): Promise<{ embedding: number[]; levenshtein_score: number }[]>;\r\n\r\n    getMemoriesByIds(ids: UUID[]): Promise<Memory[]>;\r\n    getMemoryById(id: UUID): Promise<Memory | null>;\r\n    getMemoriesByRoomIds(params: {\r\n        roomIds: UUID[];\r\n        limit?: number;\r\n    }): Promise<Memory[]>;\r\n    searchMemoriesByEmbedding(\r\n        embedding: number[],\r\n        opts: {\r\n            match_threshold?: number;\r\n            count?: number;\r\n            roomId: UUID;\r\n            unique?: boolean;\r\n        },\r\n    ): Promise<Memory[]>;\r\n\r\n    createMemory(memory: Memory, unique?: boolean): Promise<void>;\r\n\r\n    removeMemory(memoryId: UUID): Promise<void>;\r\n\r\n    removeAllMemories(roomId: UUID): Promise<void>;\r\n\r\n    countMemories(roomId: UUID, unique?: boolean): Promise<number>;\r\n}\r\n\r\nexport interface IRAGKnowledgeManager {\r\n    runtime: IAgentRuntime;\r\n    tableName: string;\r\n\r\n    getKnowledge(params: {\r\n        query?: string;\r\n        id?: UUID;\r\n        limit?: number;\r\n        conversationContext?: string;\r\n        agentId?: UUID;\r\n    }): Promise<RAGKnowledgeItem[]>;\r\n    createKnowledge(item: RAGKnowledgeItem): Promise<void>;\r\n    removeKnowledge(id: UUID): Promise<void>;\r\n    searchKnowledge(params: {\r\n        agentId: UUID;\r\n        embedding: Float32Array | number[];\r\n        match_threshold?: number;\r\n        match_count?: number;\r\n        searchText?: string;\r\n    }): Promise<RAGKnowledgeItem[]>;\r\n    clearKnowledge(shared?: boolean): Promise<void>;\r\n    processFile(file: {\r\n        path: string;\r\n        content: string;\r\n        type: \"pdf\" | \"md\" | \"txt\";\r\n        isShared: boolean;\r\n    }): Promise<void>;\r\n    cleanupDeletedKnowledgeFiles(): Promise<void>;\r\n    generateScopedId(path: string, isShared: boolean): UUID;\r\n}\r\n\r\nexport type CacheOptions = {\r\n    expires?: number;\r\n};\r\n\r\nexport enum CacheStore {\r\n    REDIS = \"redis\",\r\n    DATABASE = \"database\",\r\n    FILESYSTEM = \"filesystem\",\r\n}\r\n\r\nexport interface ICacheManager {\r\n    get<T = unknown>(key: string): Promise<T | undefined>;\r\n    set<T>(key: string, value: T, options?: CacheOptions): Promise<void>;\r\n    delete(key: string): Promise<void>;\r\n}\r\n\r\nexport abstract class Service {\r\n    private static instance: Service | null = null;\r\n\r\n    static get serviceType(): ServiceType {\r\n        throw new Error(\"Service must implement static serviceType getter\");\r\n    }\r\n\r\n    public static getInstance<T extends Service>(): T {\r\n        if (!Service.instance) {\r\n            Service.instance = new (this as any)();\r\n        }\r\n        return Service.instance as T;\r\n    }\r\n\r\n    get serviceType(): ServiceType {\r\n        return (this.constructor as typeof Service).serviceType;\r\n    }\r\n\r\n    // Add abstract initialize method that must be implemented by derived classes\r\n    abstract initialize(runtime: IAgentRuntime): Promise<void>;\r\n}\r\n\r\nexport interface IAgentRuntime {\r\n    // Properties\r\n    agentId: UUID;\r\n    serverUrl: string;\r\n    databaseAdapter: IDatabaseAdapter;\r\n    token: string | null;\r\n    modelProvider: ModelProviderName;\r\n    imageModelProvider: ModelProviderName;\r\n    imageVisionModelProvider: ModelProviderName;\r\n    character: Character;\r\n    providers: Provider[];\r\n    actions: Action[];\r\n    evaluators: Evaluator[];\r\n    plugins: Plugin[];\r\n\r\n    fetch?: typeof fetch | null;\r\n\r\n    messageManager: IMemoryManager;\r\n    descriptionManager: IMemoryManager;\r\n    documentsManager: IMemoryManager;\r\n    knowledgeManager: IMemoryManager;\r\n    ragKnowledgeManager: IRAGKnowledgeManager;\r\n    loreManager: IMemoryManager;\r\n\r\n    cacheManager: ICacheManager;\r\n\r\n    services: Map<ServiceType, Service>;\r\n    clients: ClientInstance[];\r\n\r\n    // verifiableInferenceAdapter?: IVerifiableInferenceAdapter | null;\r\n\r\n    initialize(): Promise<void>;\r\n\r\n    registerMemoryManager(manager: IMemoryManager): void;\r\n\r\n    getMemoryManager(name: string): IMemoryManager | null;\r\n\r\n    getService<T extends Service>(service: ServiceType): T | null;\r\n\r\n    registerService(service: Service): void;\r\n\r\n    getSetting(key: string): string | null;\r\n\r\n    // Methods\r\n    getConversationLength(): number;\r\n\r\n    processActions(\r\n        message: Memory,\r\n        responses: Memory[],\r\n        state?: State,\r\n        callback?: HandlerCallback,\r\n    ): Promise<void>;\r\n\r\n    evaluate(\r\n        message: Memory,\r\n        state?: State,\r\n        didRespond?: boolean,\r\n        callback?: HandlerCallback,\r\n    ): Promise<string[] | null>;\r\n\r\n    ensureParticipantExists(userId: UUID, roomId: UUID): Promise<void>;\r\n\r\n    ensureUserExists(\r\n        userId: UUID,\r\n        userName: string | null,\r\n        name: string | null,\r\n        source: string | null,\r\n    ): Promise<void>;\r\n\r\n    registerAction(action: Action): void;\r\n\r\n    ensureConnection(\r\n        userId: UUID,\r\n        roomId: UUID,\r\n        userName?: string,\r\n        userScreenName?: string,\r\n        source?: string,\r\n    ): Promise<void>;\r\n\r\n    ensureParticipantInRoom(userId: UUID, roomId: UUID): Promise<void>;\r\n\r\n    ensureRoomExists(roomId: UUID): Promise<void>;\r\n\r\n    composeState(\r\n        message: Memory,\r\n        additionalKeys?: { [key: string]: unknown },\r\n    ): Promise<State>;\r\n\r\n    updateRecentMessageState(state: State): Promise<State>;\r\n}\r\n\r\nexport interface IImageDescriptionService extends Service {\r\n    describeImage(\r\n        imageUrl: string,\r\n    ): Promise<{ title: string; description: string }>;\r\n}\r\n\r\nexport interface ITranscriptionService extends Service {\r\n    transcribeAttachment(audioBuffer: ArrayBuffer): Promise<string | null>;\r\n    transcribeAttachmentLocally(\r\n        audioBuffer: ArrayBuffer,\r\n    ): Promise<string | null>;\r\n    transcribe(audioBuffer: ArrayBuffer): Promise<string | null>;\r\n    transcribeLocally(audioBuffer: ArrayBuffer): Promise<string | null>;\r\n}\r\n\r\nexport interface IVideoService extends Service {\r\n    isVideoUrl(url: string): boolean;\r\n    fetchVideoInfo(url: string): Promise<Media>;\r\n    downloadVideo(videoInfo: Media): Promise<string>;\r\n    processVideo(url: string, runtime: IAgentRuntime): Promise<Media>;\r\n}\r\n\r\nexport interface ITextGenerationService extends Service {\r\n    initializeModel(): Promise<void>;\r\n    queueMessageCompletion(\r\n        context: string,\r\n        temperature: number,\r\n        stop: string[],\r\n        frequency_penalty: number,\r\n        presence_penalty: number,\r\n        max_tokens: number,\r\n    ): Promise<any>;\r\n    queueTextCompletion(\r\n        context: string,\r\n        temperature: number,\r\n        stop: string[],\r\n        frequency_penalty: number,\r\n        presence_penalty: number,\r\n        max_tokens: number,\r\n    ): Promise<string>;\r\n    getEmbeddingResponse(input: string): Promise<number[] | undefined>;\r\n}\r\n\r\nexport interface IBrowserService extends Service {\r\n    closeBrowser(): Promise<void>;\r\n    getPageContent(\r\n        url: string,\r\n        runtime: IAgentRuntime,\r\n    ): Promise<{ title: string; description: string; bodyContent: string }>;\r\n}\r\n\r\nexport interface ISpeechService extends Service {\r\n    getInstance(): ISpeechService;\r\n    generate(runtime: IAgentRuntime, text: string): Promise<Readable>;\r\n}\r\n\r\nexport interface IPdfService extends Service {\r\n    getInstance(): IPdfService;\r\n    convertPdfToText(pdfBuffer: Buffer): Promise<string>;\r\n}\r\n\r\nexport interface IAwsS3Service extends Service {\r\n    uploadFile(\r\n        imagePath: string,\r\n        subDirectory: string,\r\n        useSignedUrl: boolean,\r\n        expiresIn: number,\r\n    ): Promise<{\r\n        success: boolean;\r\n        url?: string;\r\n        error?: string;\r\n    }>;\r\n    generateSignedUrl(fileName: string, expiresIn: number): Promise<string>;\r\n}\r\n\r\nexport interface UploadIrysResult {\r\n    success: boolean;\r\n    url?: string;\r\n    error?: string;\r\n    data?: any;\r\n}\r\n\r\nexport interface DataIrysFetchedFromGQL {\r\n    success: boolean;\r\n    data: any;\r\n    error?: string;\r\n}\r\n\r\nexport interface GraphQLTag {\r\n    name: string;\r\n    values: any[];\r\n}\r\n\r\nexport enum IrysMessageType {\r\n    REQUEST = \"REQUEST\",\r\n    DATA_STORAGE = \"DATA_STORAGE\",\r\n    REQUEST_RESPONSE = \"REQUEST_RESPONSE\",\r\n}\r\n\r\nexport enum IrysDataType {\r\n    FILE = \"FILE\",\r\n    IMAGE = \"IMAGE\",\r\n    OTHER = \"OTHER\",\r\n}\r\n\r\nexport interface IrysTimestamp {\r\n    from: number;\r\n    to: number;\r\n}\r\n\r\nexport interface IIrysService extends Service {\r\n    getDataFromAnAgent(\r\n        agentsWalletPublicKeys: string[],\r\n        tags: GraphQLTag[],\r\n        timestamp: IrysTimestamp,\r\n    ): Promise<DataIrysFetchedFromGQL>;\r\n    workerUploadDataOnIrys(\r\n        data: any,\r\n        dataType: IrysDataType,\r\n        messageType: IrysMessageType,\r\n        serviceCategory: string[],\r\n        protocol: string[],\r\n        validationThreshold: number[],\r\n        minimumProviders: number[],\r\n        testProvider: boolean[],\r\n        reputation: number[],\r\n    ): Promise<UploadIrysResult>;\r\n    providerUploadDataOnIrys(\r\n        data: any,\r\n        dataType: IrysDataType,\r\n        serviceCategory: string[],\r\n        protocol: string[],\r\n    ): Promise<UploadIrysResult>;\r\n}\r\n\r\nexport interface ITeeLogService extends Service {\r\n    getInstance(): ITeeLogService;\r\n    log(\r\n        agentId: string,\r\n        roomId: string,\r\n        userId: string,\r\n        type: string,\r\n        content: string,\r\n    ): Promise<boolean>;\r\n}\r\n\r\nexport enum ServiceType {\r\n    IMAGE_DESCRIPTION = \"image_description\",\r\n    TRANSCRIPTION = \"transcription\",\r\n    VIDEO = \"video\",\r\n    TEXT_GENERATION = \"text_generation\",\r\n    BROWSER = \"browser\",\r\n    SPEECH_GENERATION = \"speech_generation\",\r\n    PDF = \"pdf\",\r\n    INTIFACE = \"intiface\",\r\n    AWS_S3 = \"aws_s3\",\r\n    BUTTPLUG = \"buttplug\",\r\n    SLACK = \"slack\",\r\n    VERIFIABLE_LOGGING = \"verifiable_logging\",\r\n    IRYS = \"irys\",\r\n    TEE_LOG = \"tee_log\",\r\n    GOPLUS_SECURITY = \"goplus_security\",\r\n    WEB_SEARCH = \"web_search\",\r\n    EMAIL_AUTOMATION = \"email_automation\",\r\n    NKN_CLIENT_SERVICE = \"nkn_client_service\",\r\n}\r\n\r\nexport enum LoggingLevel {\r\n    DEBUG = \"debug\",\r\n    VERBOSE = \"verbose\",\r\n    NONE = \"none\",\r\n}\r\n\r\nexport type KnowledgeItem = {\r\n    id: UUID;\r\n    content: Content;\r\n};\r\n\r\nexport interface RAGKnowledgeItem {\r\n    id: UUID;\r\n    agentId: UUID;\r\n    content: {\r\n        text: string;\r\n        metadata?: {\r\n            isMain?: boolean;\r\n            isChunk?: boolean;\r\n            originalId?: UUID;\r\n            chunkIndex?: number;\r\n            source?: string;\r\n            type?: string;\r\n            isShared?: boolean;\r\n            [key: string]: unknown;\r\n        };\r\n    };\r\n    embedding?: Float32Array;\r\n    createdAt?: number;\r\n    similarity?: number;\r\n    score?: number;\r\n}\r\n\r\nexport interface ActionResponse {\r\n    like: boolean;\r\n    retweet: boolean;\r\n    quote?: boolean;\r\n    reply?: boolean;\r\n}\r\n\r\nexport interface ISlackService extends Service {\r\n    client: any;\r\n}\r\n\r\nexport enum TokenizerType {\r\n    Auto = \"auto\",\r\n    TikToken = \"tiktoken\",\r\n}\r\n\r\nexport enum TranscriptionProvider {\r\n    OpenAI = \"openai\",\r\n    Deepgram = \"deepgram\",\r\n    Local = \"local\",\r\n}\r\n\r\nexport enum ActionTimelineType {\r\n    ForYou = \"foryou\",\r\n    Following = \"following\",\r\n}\r\nexport enum KnowledgeScope {\r\n    SHARED = \"shared\",\r\n    PRIVATE = \"private\",\r\n}\r\n\r\nexport enum CacheKeyPrefix {\r\n    KNOWLEDGE = \"knowledge\",\r\n}\r\n\r\nexport interface DirectoryItem {\r\n    directory: string;\r\n    shared?: boolean;\r\n}\r\n\r\nexport interface ChunkRow {\r\n    id: string;\r\n    // Add other properties if needed\r\n}\r\n","import {\r\n  uuidSchema as coreUuidSchema,\r\n  validateUuid as coreValidateUuid,\r\n  stringToUuid as coreStringToUuid\r\n} from '@elizaos/core';\r\nimport type { UUID } from \"./types.ts\";\r\n\r\nexport const uuidSchema = coreUuidSchema;\r\n\r\nexport function validateUuid(value: unknown): UUID | null {\r\n  return coreValidateUuid(value);\r\n}\r\n\r\nexport function stringToUuid(target: string | number): UUID {\r\n  return coreStringToUuid(target);\r\n}","import {\r\n  models as coreModels,\r\n  getModelSettings as coreGetModelSettings,\r\n  getImageModelSettings as coreGetImageModelSettings,\r\n  getEmbeddingModelSettings as coreGetEmbeddingModelSettings,\r\n  getEndpoint as coreGetEndpoint,\r\n} from '@elizaos/core';\r\nimport {\r\n    type EmbeddingModelSettings,\r\n    type ImageModelSettings,\r\n    ModelClass,\r\n    ModelProviderName,\r\n    type Models,\r\n    type ModelSettings,\r\n} from \"./types.ts\";\r\n\r\nexport const models: Models = coreModels\r\n\r\nexport function getModelSettings(\r\n    provider: ModelProviderName,\r\n    type: ModelClass\r\n): ModelSettings | undefined {\r\n    return coreGetModelSettings(provider, type);\r\n}\r\n\r\nexport function getImageModelSettings(\r\n    provider: ModelProviderName\r\n): ImageModelSettings | undefined {\r\n    return coreGetImageModelSettings(provider);\r\n}\r\n\r\nexport function getEmbeddingModelSettings(\r\n    provider: ModelProviderName\r\n): EmbeddingModelSettings | undefined {\r\n    return coreGetEmbeddingModelSettings(provider);\r\n}\r\n\r\nexport function getEndpoint(provider: ModelProviderName) {\r\n    return coreGetEndpoint(provider);\r\n}\r\n"],"mappings":"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","names":["coreAgentRuntime","settings","GoalStatus","ModelClass","ModelProviderName","CacheStore","IrysMessageType","IrysDataType","ServiceType","LoggingLevel","TokenizerType","TranscriptionProvider","ActionTimelineType","KnowledgeScope","CacheKeyPrefix"]}