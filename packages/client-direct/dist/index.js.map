{"version":3,"sources":["../src/index.ts","../src/api.ts","../src/verifiable-log-api.ts"],"sourcesContent":["import {\r\n    composeContext,\r\n    elizaLogger,\r\n    generateCaption,\r\n    generateImage,\r\n    generateMessageResponse,\r\n    generateObject,\r\n    getEmbeddingZeroVector,\r\n    messageCompletionFooter,\r\n    ModelClass,\r\n    settings,\r\n    stringToUuid,\r\n    type Client,\r\n    type Content,\r\n    type IAgentRuntime,\r\n    type Media,\r\n    type Memory,\r\n    type Plugin,\r\n} from \"@elizaos/core\";\r\nimport bodyParser from \"body-parser\";\r\nimport cors from \"cors\";\r\nimport express, { type Request as ExpressRequest } from \"express\";\r\nimport * as fs from \"fs\";\r\nimport multer from \"multer\";\r\nimport OpenAI from \"openai\";\r\nimport * as path from \"path\";\r\nimport { z } from \"zod\";\r\nimport { createApiRouter } from \"./api.ts\";\r\nimport { createVerifiableLogApiRouter } from \"./verifiable-log-api.ts\";\r\n\r\nexport type Middleware = (\r\n    req: express.Request,\r\n    res: express.Response,\r\n    next: express.NextFunction\r\n) => void;\r\n\r\nconst storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n        const uploadDir = path.join(process.cwd(), \"data\", \"uploads\");\r\n        // Create the directory if it doesn't exist\r\n        if (!fs.existsSync(uploadDir)) {\r\n            fs.mkdirSync(uploadDir, { recursive: true });\r\n        }\r\n        cb(null, uploadDir);\r\n    },\r\n    filename: (req, file, cb) => {\r\n        const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;\r\n        cb(null, `${uniqueSuffix}-${file.originalname}`);\r\n    },\r\n});\r\n\r\n// some people have more memory than disk.io\r\nconst upload = multer({ storage /*: multer.memoryStorage() */ });\r\n\r\nexport const messageHandlerTemplate =\r\n    // {{goals}}\r\n    // \"# Action Examples\" is already included\r\n    `{{actionExamples}}\r\n(Action examples are for reference only. Do not use the information from them in your response.)\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\n# Task: Generate dialog and actions for the character {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\n{{providers}}\r\n\r\n{{attachments}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n{{actions}}\r\n\r\n# Instructions: Write the next message for {{agentName}}.\r\n` + messageCompletionFooter;\r\n\r\nexport const hyperfiHandlerTemplate = `{{actionExamples}}\r\n(Action examples are for reference only. Do not use the information from them in your response.)\r\n\r\n# Knowledge\r\n{{knowledge}}\r\n\r\n# Task: Generate dialog and actions for the character {{agentName}}.\r\nAbout {{agentName}}:\r\n{{bio}}\r\n{{lore}}\r\n\r\n{{providers}}\r\n\r\n{{attachments}}\r\n\r\n# Capabilities\r\nNote that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\r\n\r\n{{messageDirections}}\r\n\r\n{{recentMessages}}\r\n\r\n{{actions}}\r\n\r\n# Instructions: Write the next message for {{agentName}}.\r\n\r\nResponse format should be formatted in a JSON block like this:\r\n\\`\\`\\`json\r\n{ \"lookAt\": \"{{nearby}}\" or null, \"emote\": \"{{emotes}}\" or null, \"say\": \"string\" or null, \"actions\": (array of strings) or null }\r\n\\`\\`\\`\r\n`;\r\n\r\nexport class DirectClient {\r\n    public app: express.Application;\r\n    private agents: Map<string, IAgentRuntime>; // container management\r\n    private server: any; // Store server instance\r\n    public startAgent: Function; // Store startAgent functor\r\n    public loadCharacterTryPath: Function; // Store loadCharacterTryPath functor\r\n    public jsonToCharacter: Function; // Store jsonToCharacter functor\r\n\r\n    constructor() {\r\n        elizaLogger.log(\"DirectClient constructor\");\r\n        this.app = express();\r\n        this.app.use(cors());\r\n        this.agents = new Map();\r\n\r\n        this.app.use(bodyParser.json());\r\n        this.app.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n        // Serve both uploads and generated images\r\n        this.app.use(\r\n            \"/media/uploads\",\r\n            express.static(path.join(process.cwd(), \"/data/uploads\"))\r\n        );\r\n        this.app.use(\r\n            \"/media/generated\",\r\n            express.static(path.join(process.cwd(), \"/generatedImages\"))\r\n        );\r\n\r\n        const apiRouter = createApiRouter(this.agents, this);\r\n        this.app.use(apiRouter);\r\n\r\n        const apiLogRouter = createVerifiableLogApiRouter(this.agents);\r\n        this.app.use(apiLogRouter);\r\n\r\n        // Define an interface that extends the Express Request interface\r\n        interface CustomRequest extends ExpressRequest {\r\n            file?: Express.Multer.File;\r\n        }\r\n\r\n        // Update the route handler to use CustomRequest instead of express.Request\r\n        this.app.post(\r\n            \"/:agentId/whisper\",\r\n            upload.single(\"file\"),\r\n            async (req: CustomRequest, res: express.Response) => {\r\n                const audioFile = req.file; // Access the uploaded file using req.file\r\n                const agentId = req.params.agentId;\r\n\r\n                if (!audioFile) {\r\n                    res.status(400).send(\"No audio file provided\");\r\n                    return;\r\n                }\r\n\r\n                let runtime = this.agents.get(agentId);\r\n                const apiKey = runtime.getSetting(\"OPENAI_API_KEY\");\r\n\r\n                // if runtime is null, look for runtime with the same name\r\n                if (!runtime) {\r\n                    runtime = Array.from(this.agents.values()).find(\r\n                        (a) =>\r\n                            a.character.name.toLowerCase() ===\r\n                            agentId.toLowerCase()\r\n                    );\r\n                }\r\n\r\n                if (!runtime) {\r\n                    res.status(404).send(\"Agent not found\");\r\n                    return;\r\n                }\r\n\r\n                const openai = new OpenAI({\r\n                    apiKey,\r\n                });\r\n\r\n                const transcription = await openai.audio.transcriptions.create({\r\n                    file: fs.createReadStream(audioFile.path),\r\n                    model: \"whisper-1\",\r\n                });\r\n\r\n                res.json(transcription);\r\n            }\r\n        );\r\n\r\n        this.app.post(\r\n            \"/:agentId/message\",\r\n            upload.single(\"file\"),\r\n            async (req: express.Request, res: express.Response) => {\r\n                const agentId = req.params.agentId;\r\n                const roomId = stringToUuid(\r\n                    req.body.roomId ?? \"default-room-\" + agentId\r\n                );\r\n                const userId = stringToUuid(req.body.userId ?? \"user\");\r\n\r\n                let runtime = this.agents.get(agentId);\r\n\r\n                // if runtime is null, look for runtime with the same name\r\n                if (!runtime) {\r\n                    runtime = Array.from(this.agents.values()).find(\r\n                        (a) =>\r\n                            a.character.name.toLowerCase() ===\r\n                            agentId.toLowerCase()\r\n                    );\r\n                }\r\n\r\n                if (!runtime) {\r\n                    res.status(404).send(\"Agent not found\");\r\n                    return;\r\n                }\r\n\r\n                await runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    req.body.userName,\r\n                    req.body.name,\r\n                    \"direct\"\r\n                );\r\n\r\n                const text = req.body.text;\r\n                // if empty text, directly return\r\n                if (!text) {\r\n                    res.json([]);\r\n                    return;\r\n                }\r\n\r\n                const messageId = stringToUuid(Date.now().toString());\r\n\r\n                const attachments: Media[] = [];\r\n                if (req.file) {\r\n                    const filePath = path.join(\r\n                        process.cwd(),\r\n                        \"data\",\r\n                        \"uploads\",\r\n                        req.file.filename\r\n                    );\r\n                    attachments.push({\r\n                        id: Date.now().toString(),\r\n                        url: filePath,\r\n                        title: req.file.originalname,\r\n                        source: \"direct\",\r\n                        description: `Uploaded file: ${req.file.originalname}`,\r\n                        text: \"\",\r\n                        contentType: req.file.mimetype,\r\n                    });\r\n                }\r\n\r\n                const content: Content = {\r\n                    text,\r\n                    attachments,\r\n                    source: \"direct\",\r\n                    inReplyTo: undefined,\r\n                };\r\n\r\n                const userMessage = {\r\n                    content,\r\n                    userId,\r\n                    roomId,\r\n                    agentId: runtime.agentId,\r\n                };\r\n\r\n                const memory: Memory = {\r\n                    id: stringToUuid(messageId + \"-\" + userId),\r\n                    ...userMessage,\r\n                    agentId: runtime.agentId,\r\n                    userId,\r\n                    roomId,\r\n                    content,\r\n                    createdAt: Date.now(),\r\n                };\r\n\r\n                await runtime.messageManager.addEmbeddingToMemory(memory);\r\n                await runtime.messageManager.createMemory(memory);\r\n\r\n                let state = await runtime.composeState(userMessage, {\r\n                    agentName: runtime.character.name,\r\n                });\r\n\r\n                const context = composeContext({\r\n                    state,\r\n                    template: messageHandlerTemplate,\r\n                });\r\n\r\n                const response = await generateMessageResponse({\r\n                    runtime: runtime,\r\n                    context,\r\n                    modelClass: ModelClass.LARGE,\r\n                });\r\n\r\n                if (!response) {\r\n                    res.status(500).send(\r\n                        \"No response from generateMessageResponse\"\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // save response to memory\r\n                const responseMessage: Memory = {\r\n                    id: stringToUuid(messageId + \"-\" + runtime.agentId),\r\n                    ...userMessage,\r\n                    userId: runtime.agentId,\r\n                    content: response,\r\n                    embedding: getEmbeddingZeroVector(),\r\n                    createdAt: Date.now(),\r\n                };\r\n\r\n                await runtime.messageManager.createMemory(responseMessage);\r\n\r\n                state = await runtime.updateRecentMessageState(state);\r\n\r\n                let message = null as Content | null;\r\n\r\n                await runtime.processActions(\r\n                    memory,\r\n                    [responseMessage],\r\n                    state,\r\n                    async (newMessages) => {\r\n                        message = newMessages;\r\n                        return [memory];\r\n                    }\r\n                );\r\n\r\n                await runtime.evaluate(memory, state);\r\n\r\n                // Check if we should suppress the initial message\r\n                const action = runtime.actions.find(\r\n                    (a) => a.name === response.action\r\n                );\r\n                const shouldSuppressInitialMessage =\r\n                    action?.suppressInitialMessage;\r\n\r\n                if (!shouldSuppressInitialMessage) {\r\n                    if (message) {\r\n                        res.json([response, message]);\r\n                    } else {\r\n                        res.json([response]);\r\n                    }\r\n                } else {\r\n                    if (message) {\r\n                        res.json([message]);\r\n                    } else {\r\n                        res.json([]);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n\r\n        this.app.post(\r\n            \"/agents/:agentIdOrName/hyperfi/v1\",\r\n            async (req: express.Request, res: express.Response) => {\r\n                // get runtime\r\n                const agentId = req.params.agentIdOrName;\r\n                let runtime = this.agents.get(agentId);\r\n                // if runtime is null, look for runtime with the same name\r\n                if (!runtime) {\r\n                    runtime = Array.from(this.agents.values()).find(\r\n                        (a) =>\r\n                            a.character.name.toLowerCase() ===\r\n                            agentId.toLowerCase()\r\n                    );\r\n                }\r\n                if (!runtime) {\r\n                    res.status(404).send(\"Agent not found\");\r\n                    return;\r\n                }\r\n\r\n                // can we be in more than one hyperfi world at once\r\n                // but you may want the same context is multiple worlds\r\n                // this is more like an instanceId\r\n                const roomId = stringToUuid(req.body.roomId ?? \"hyperfi\");\r\n\r\n                const body = req.body;\r\n\r\n                // hyperfi specific parameters\r\n                let nearby = [];\r\n                let availableEmotes = [];\r\n\r\n                if (body.nearby) {\r\n                    nearby = body.nearby;\r\n                }\r\n                if (body.messages) {\r\n                    // loop on the messages and record the memories\r\n                    // might want to do this in parallel\r\n                    for (const msg of body.messages) {\r\n                        const parts = msg.split(/:\\s*/);\r\n                        const mUserId = stringToUuid(parts[0]);\r\n                        await runtime.ensureConnection(\r\n                            mUserId,\r\n                            roomId, // where\r\n                            parts[0], // username\r\n                            parts[0], // userScreeName?\r\n                            \"hyperfi\"\r\n                        );\r\n                        const content: Content = {\r\n                            text: parts[1] || \"\",\r\n                            attachments: [],\r\n                            source: \"hyperfi\",\r\n                            inReplyTo: undefined,\r\n                        };\r\n                        const memory: Memory = {\r\n                            id: stringToUuid(msg),\r\n                            agentId: runtime.agentId,\r\n                            userId: mUserId,\r\n                            roomId,\r\n                            content,\r\n                        };\r\n                        await runtime.messageManager.createMemory(memory);\r\n                    }\r\n                }\r\n                if (body.availableEmotes) {\r\n                    availableEmotes = body.availableEmotes;\r\n                }\r\n\r\n                const content: Content = {\r\n                    // we need to compose who's near and what emotes are available\r\n                    text: JSON.stringify(req.body),\r\n                    attachments: [],\r\n                    source: \"hyperfi\",\r\n                    inReplyTo: undefined,\r\n                };\r\n\r\n                const userId = stringToUuid(\"hyperfi\");\r\n                const userMessage = {\r\n                    content,\r\n                    userId,\r\n                    roomId,\r\n                    agentId: runtime.agentId,\r\n                };\r\n\r\n                const state = await runtime.composeState(userMessage, {\r\n                    agentName: runtime.character.name,\r\n                });\r\n\r\n                let template = hyperfiHandlerTemplate;\r\n                template = template.replace(\r\n                    \"{{emotes}}\",\r\n                    availableEmotes.join(\"|\")\r\n                );\r\n                template = template.replace(\"{{nearby}}\", nearby.join(\"|\"));\r\n                const context = composeContext({\r\n                    state,\r\n                    template,\r\n                });\r\n\r\n                function createHyperfiOutSchema(\r\n                    nearby: string[],\r\n                    availableEmotes: string[]\r\n                ) {\r\n                    const lookAtSchema =\r\n                        nearby.length > 1\r\n                            ? z\r\n                                  .union(\r\n                                      nearby.map((item) => z.literal(item)) as [\r\n                                          z.ZodLiteral<string>,\r\n                                          z.ZodLiteral<string>,\r\n                                          ...z.ZodLiteral<string>[]\r\n                                      ]\r\n                                  )\r\n                                  .nullable()\r\n                            : nearby.length === 1\r\n                            ? z.literal(nearby[0]).nullable()\r\n                            : z.null(); // Fallback for empty array\r\n\r\n                    const emoteSchema =\r\n                        availableEmotes.length > 1\r\n                            ? z\r\n                                  .union(\r\n                                      availableEmotes.map((item) =>\r\n                                          z.literal(item)\r\n                                      ) as [\r\n                                          z.ZodLiteral<string>,\r\n                                          z.ZodLiteral<string>,\r\n                                          ...z.ZodLiteral<string>[]\r\n                                      ]\r\n                                  )\r\n                                  .nullable()\r\n                            : availableEmotes.length === 1\r\n                            ? z.literal(availableEmotes[0]).nullable()\r\n                            : z.null(); // Fallback for empty array\r\n\r\n                    return z.object({\r\n                        lookAt: lookAtSchema,\r\n                        emote: emoteSchema,\r\n                        say: z.string().nullable(),\r\n                        actions: z.array(z.string()).nullable(),\r\n                    });\r\n                }\r\n\r\n                // Define the schema for the expected output\r\n                const hyperfiOutSchema = createHyperfiOutSchema(\r\n                    nearby,\r\n                    availableEmotes\r\n                );\r\n\r\n                // Call LLM\r\n                const response = await generateObject({\r\n                    runtime,\r\n                    context,\r\n                    modelClass: ModelClass.SMALL, // 1s processing time on openai small\r\n                    schema: hyperfiOutSchema,\r\n                });\r\n\r\n                if (!response) {\r\n                    res.status(500).send(\r\n                        \"No response from generateMessageResponse\"\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                let hfOut;\r\n                try {\r\n                    hfOut = hyperfiOutSchema.parse(response.object);\r\n                } catch {\r\n                    elizaLogger.error(\r\n                        \"cant serialize response\",\r\n                        response.object\r\n                    );\r\n                    res.status(500).send(\"Error in LLM response, try again\");\r\n                    return;\r\n                }\r\n\r\n                // do this in the background\r\n                new Promise((resolve) => {\r\n                    const contentObj: Content = {\r\n                        text: hfOut.say,\r\n                    };\r\n\r\n                    if (hfOut.lookAt !== null || hfOut.emote !== null) {\r\n                        contentObj.text += \". Then I \";\r\n                        if (hfOut.lookAt !== null) {\r\n                            contentObj.text += \"looked at \" + hfOut.lookAt;\r\n                            if (hfOut.emote !== null) {\r\n                                contentObj.text += \" and \";\r\n                            }\r\n                        }\r\n                        if (hfOut.emote !== null) {\r\n                            contentObj.text = \"emoted \" + hfOut.emote;\r\n                        }\r\n                    }\r\n\r\n                    if (hfOut.actions !== null) {\r\n                        // content can only do one action\r\n                        contentObj.action = hfOut.actions[0];\r\n                    }\r\n\r\n                    // save response to memory\r\n                    const responseMessage = {\r\n                        ...userMessage,\r\n                        userId: runtime.agentId,\r\n                        content: contentObj,\r\n                    };\r\n\r\n                    runtime.messageManager\r\n                        .createMemory(responseMessage)\r\n                        .then(() => {\r\n                            const messageId = stringToUuid(\r\n                                Date.now().toString()\r\n                            );\r\n                            const memory: Memory = {\r\n                                id: messageId,\r\n                                agentId: runtime.agentId,\r\n                                userId,\r\n                                roomId,\r\n                                content,\r\n                                createdAt: Date.now(),\r\n                            };\r\n\r\n                            // run evaluators (generally can be done in parallel with processActions)\r\n                            // can an evaluator modify memory? it could but currently doesn't\r\n                            runtime.evaluate(memory, state).then(() => {\r\n                                // only need to call if responseMessage.content.action is set\r\n                                if (contentObj.action) {\r\n                                    // pass memory (query) to any actions to call\r\n                                    runtime.processActions(\r\n                                        memory,\r\n                                        [responseMessage],\r\n                                        state,\r\n                                        async (_newMessages) => {\r\n                                            // FIXME: this is supposed override what the LLM said/decided\r\n                                            // but the promise doesn't make this possible\r\n                                            //message = newMessages;\r\n                                            return [memory];\r\n                                        }\r\n                                    ); // 0.674s\r\n                                }\r\n                                resolve(true);\r\n                            });\r\n                        });\r\n                });\r\n                res.json({ response: hfOut });\r\n            }\r\n        );\r\n\r\n        this.app.post(\r\n            \"/:agentId/image\",\r\n            async (req: express.Request, res: express.Response) => {\r\n                const agentId = req.params.agentId;\r\n                const agent = this.agents.get(agentId);\r\n                if (!agent) {\r\n                    res.status(404).send(\"Agent not found\");\r\n                    return;\r\n                }\r\n\r\n                const images = await generateImage({ ...req.body }, agent);\r\n                const imagesRes: { image: string; caption: string }[] = [];\r\n                if (images.data && images.data.length > 0) {\r\n                    for (let i = 0; i < images.data.length; i++) {\r\n                        const caption = await generateCaption(\r\n                            { imageUrl: images.data[i] },\r\n                            agent\r\n                        );\r\n                        imagesRes.push({\r\n                            image: images.data[i],\r\n                            caption: caption.title,\r\n                        });\r\n                    }\r\n                }\r\n                res.json({ images: imagesRes });\r\n            }\r\n        );\r\n\r\n        this.app.post(\r\n            \"/fine-tune\",\r\n            async (req: express.Request, res: express.Response) => {\r\n                try {\r\n                    const response = await fetch(\r\n                        \"https://api.bageldb.ai/api/v1/asset\",\r\n                        {\r\n                            method: \"POST\",\r\n                            headers: {\r\n                                \"Content-Type\": \"application/json\",\r\n                                \"X-API-KEY\": `${process.env.BAGEL_API_KEY}`,\r\n                            },\r\n                            body: JSON.stringify(req.body),\r\n                        }\r\n                    );\r\n\r\n                    const data = await response.json();\r\n                    res.json(data);\r\n                } catch (error) {\r\n                    res.status(500).json({\r\n                        error: \"Please create an account at bakery.bagel.net and get an API key. Then set the BAGEL_API_KEY environment variable.\",\r\n                        details: error.message,\r\n                    });\r\n                }\r\n            }\r\n        );\r\n        this.app.get(\r\n            \"/fine-tune/:assetId\",\r\n            async (req: express.Request, res: express.Response) => {\r\n                const assetId = req.params.assetId;\r\n\r\n                const ROOT_DIR = path.join(process.cwd(), \"downloads\");\r\n                const downloadDir = path.resolve(ROOT_DIR, assetId);\r\n\r\n                if (!downloadDir.startsWith(ROOT_DIR)) {\r\n                    res.status(403).json({\r\n                        error: \"Invalid assetId. Access denied.\",\r\n                    });\r\n                    return;\r\n                }\r\n                elizaLogger.log(\"Download directory:\", downloadDir);\r\n\r\n                try {\r\n                    elizaLogger.log(\"Creating directory...\");\r\n                    await fs.promises.mkdir(downloadDir, { recursive: true });\r\n\r\n                    elizaLogger.log(\"Fetching file...\");\r\n                    const fileResponse = await fetch(\r\n                        `https://api.bageldb.ai/api/v1/asset/${assetId}/download`,\r\n                        {\r\n                            headers: {\r\n                                \"X-API-KEY\": `${process.env.BAGEL_API_KEY}`,\r\n                            },\r\n                        }\r\n                    );\r\n\r\n                    if (!fileResponse.ok) {\r\n                        throw new Error(\r\n                            `API responded with status ${\r\n                                fileResponse.status\r\n                            }: ${await fileResponse.text()}`\r\n                        );\r\n                    }\r\n\r\n                    elizaLogger.log(\"Response headers:\", fileResponse.headers);\r\n\r\n                    const fileName =\r\n                        fileResponse.headers\r\n                            .get(\"content-disposition\")\r\n                            ?.split(\"filename=\")[1]\r\n                            ?.replace(/\"/g, /* \" */ \"\") || \"default_name.txt\";\r\n\r\n                    elizaLogger.log(\"Saving as:\", fileName);\r\n\r\n                    const arrayBuffer = await fileResponse.arrayBuffer();\r\n                    const buffer = Buffer.from(arrayBuffer);\r\n\r\n                    const filePath = path.join(downloadDir, fileName);\r\n                    elizaLogger.log(\"Full file path:\", filePath);\r\n\r\n                    await fs.promises.writeFile(\r\n                        filePath,\r\n                        new Uint8Array(buffer)\r\n                    );\r\n\r\n                    // Verify file was written\r\n                    const stats = await fs.promises.stat(filePath);\r\n                    elizaLogger.log(\r\n                        \"File written successfully. Size:\",\r\n                        stats.size,\r\n                        \"bytes\"\r\n                    );\r\n\r\n                    res.json({\r\n                        success: true,\r\n                        message: \"Single file downloaded successfully\",\r\n                        downloadPath: downloadDir,\r\n                        fileCount: 1,\r\n                        fileName: fileName,\r\n                        fileSize: stats.size,\r\n                    });\r\n                } catch (error) {\r\n                    elizaLogger.error(\"Detailed error:\", error);\r\n                    res.status(500).json({\r\n                        error: \"Failed to download files from BagelDB\",\r\n                        details: error.message,\r\n                        stack: error.stack,\r\n                    });\r\n                }\r\n            }\r\n        );\r\n\r\n        this.app.post(\"/:agentId/speak\", async (req, res) => {\r\n            const agentId = req.params.agentId;\r\n            const roomId = stringToUuid(\r\n                req.body.roomId ?? \"default-room-\" + agentId\r\n            );\r\n            const userId = stringToUuid(req.body.userId ?? \"user\");\r\n            const text = req.body.text;\r\n\r\n            if (!text) {\r\n                res.status(400).send(\"No text provided\");\r\n                return;\r\n            }\r\n\r\n            let runtime = this.agents.get(agentId);\r\n\r\n            // if runtime is null, look for runtime with the same name\r\n            if (!runtime) {\r\n                runtime = Array.from(this.agents.values()).find(\r\n                    (a) =>\r\n                        a.character.name.toLowerCase() === agentId.toLowerCase()\r\n                );\r\n            }\r\n\r\n            if (!runtime) {\r\n                res.status(404).send(\"Agent not found\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Process message through agent (same as /message endpoint)\r\n                await runtime.ensureConnection(\r\n                    userId,\r\n                    roomId,\r\n                    req.body.userName,\r\n                    req.body.name,\r\n                    \"direct\"\r\n                );\r\n\r\n                const messageId = stringToUuid(Date.now().toString());\r\n\r\n                const content: Content = {\r\n                    text,\r\n                    attachments: [],\r\n                    source: \"direct\",\r\n                    inReplyTo: undefined,\r\n                };\r\n\r\n                const userMessage = {\r\n                    content,\r\n                    userId,\r\n                    roomId,\r\n                    agentId: runtime.agentId,\r\n                };\r\n\r\n                const memory: Memory = {\r\n                    id: messageId,\r\n                    agentId: runtime.agentId,\r\n                    userId,\r\n                    roomId,\r\n                    content,\r\n                    createdAt: Date.now(),\r\n                };\r\n\r\n                await runtime.messageManager.createMemory(memory);\r\n\r\n                const state = await runtime.composeState(userMessage, {\r\n                    agentName: runtime.character.name,\r\n                });\r\n\r\n                const context = composeContext({\r\n                    state,\r\n                    template: messageHandlerTemplate,\r\n                });\r\n\r\n                const response = await generateMessageResponse({\r\n                    runtime: runtime,\r\n                    context,\r\n                    modelClass: ModelClass.LARGE,\r\n                });\r\n\r\n                // save response to memory\r\n                const responseMessage = {\r\n                    ...userMessage,\r\n                    userId: runtime.agentId,\r\n                    content: response,\r\n                };\r\n\r\n                await runtime.messageManager.createMemory(responseMessage);\r\n\r\n                if (!response) {\r\n                    res.status(500).send(\r\n                        \"No response from generateMessageResponse\"\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                await runtime.evaluate(memory, state);\r\n\r\n                const _result = await runtime.processActions(\r\n                    memory,\r\n                    [responseMessage],\r\n                    state,\r\n                    async () => {\r\n                        return [memory];\r\n                    }\r\n                );\r\n\r\n                // Get the text to convert to speech\r\n                const textToSpeak = response.text;\r\n\r\n                // Convert to speech using ElevenLabs\r\n                const elevenLabsApiUrl = `https://api.elevenlabs.io/v1/text-to-speech/${process.env.ELEVENLABS_VOICE_ID}`;\r\n                const apiKey = process.env.ELEVENLABS_XI_API_KEY;\r\n\r\n                if (!apiKey) {\r\n                    throw new Error(\"ELEVENLABS_XI_API_KEY not configured\");\r\n                }\r\n\r\n                const speechResponse = await fetch(elevenLabsApiUrl, {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                        \"xi-api-key\": apiKey,\r\n                    },\r\n                    body: JSON.stringify({\r\n                        text: textToSpeak,\r\n                        model_id:\r\n                            process.env.ELEVENLABS_MODEL_ID ||\r\n                            \"eleven_multilingual_v2\",\r\n                        voice_settings: {\r\n                            stability: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_STABILITY || \"0.5\"\r\n                            ),\r\n                            similarity_boost: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST ||\r\n                                    \"0.9\"\r\n                            ),\r\n                            style: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_STYLE || \"0.66\"\r\n                            ),\r\n                            use_speaker_boost:\r\n                                process.env\r\n                                    .ELEVENLABS_VOICE_USE_SPEAKER_BOOST ===\r\n                                \"true\",\r\n                        },\r\n                    }),\r\n                });\r\n\r\n                if (!speechResponse.ok) {\r\n                    throw new Error(\r\n                        `ElevenLabs API error: ${speechResponse.statusText}`\r\n                    );\r\n                }\r\n\r\n                const audioBuffer = await speechResponse.arrayBuffer();\r\n\r\n                // Set appropriate headers for audio streaming\r\n                res.set({\r\n                    \"Content-Type\": \"audio/mpeg\",\r\n                    \"Transfer-Encoding\": \"chunked\",\r\n                });\r\n\r\n                res.send(Buffer.from(audioBuffer));\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    \"Error processing message or generating speech:\",\r\n                    error\r\n                );\r\n                res.status(500).json({\r\n                    error: \"Error processing message or generating speech\",\r\n                    details: error.message,\r\n                });\r\n            }\r\n        });\r\n\r\n        this.app.post(\"/:agentId/tts\", async (req, res) => {\r\n            const text = req.body.text;\r\n\r\n            if (!text) {\r\n                res.status(400).send(\"No text provided\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                // Convert to speech using ElevenLabs\r\n                const elevenLabsApiUrl = `https://api.elevenlabs.io/v1/text-to-speech/${process.env.ELEVENLABS_VOICE_ID}`;\r\n                const apiKey = process.env.ELEVENLABS_XI_API_KEY;\r\n\r\n                if (!apiKey) {\r\n                    throw new Error(\"ELEVENLABS_XI_API_KEY not configured\");\r\n                }\r\n\r\n                const speechResponse = await fetch(elevenLabsApiUrl, {\r\n                    method: \"POST\",\r\n                    headers: {\r\n                        \"Content-Type\": \"application/json\",\r\n                        \"xi-api-key\": apiKey,\r\n                    },\r\n                    body: JSON.stringify({\r\n                        text,\r\n                        model_id:\r\n                            process.env.ELEVENLABS_MODEL_ID ||\r\n                            \"eleven_multilingual_v2\",\r\n                        voice_settings: {\r\n                            stability: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_STABILITY || \"0.5\"\r\n                            ),\r\n                            similarity_boost: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_SIMILARITY_BOOST ||\r\n                                    \"0.9\"\r\n                            ),\r\n                            style: Number.parseFloat(\r\n                                process.env.ELEVENLABS_VOICE_STYLE || \"0.66\"\r\n                            ),\r\n                            use_speaker_boost:\r\n                                process.env\r\n                                    .ELEVENLABS_VOICE_USE_SPEAKER_BOOST ===\r\n                                \"true\",\r\n                        },\r\n                    }),\r\n                });\r\n\r\n                if (!speechResponse.ok) {\r\n                    throw new Error(\r\n                        `ElevenLabs API error: ${speechResponse.statusText}`\r\n                    );\r\n                }\r\n\r\n                const audioBuffer = await speechResponse.arrayBuffer();\r\n\r\n                res.set({\r\n                    \"Content-Type\": \"audio/mpeg\",\r\n                    \"Transfer-Encoding\": \"chunked\",\r\n                });\r\n\r\n                res.send(Buffer.from(audioBuffer));\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    \"Error processing message or generating speech:\",\r\n                    error\r\n                );\r\n                res.status(500).json({\r\n                    error: \"Error processing message or generating speech\",\r\n                    details: error.message,\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    // agent/src/index.ts:startAgent calls this\r\n    public registerAgent(runtime: IAgentRuntime) {\r\n        // register any plugin endpoints?\r\n        // but once and only once\r\n        this.agents.set(runtime.agentId, runtime);\r\n    }\r\n\r\n    public unregisterAgent(runtime: IAgentRuntime) {\r\n        this.agents.delete(runtime.agentId);\r\n    }\r\n\r\n    public registerMiddleware(middleware: Middleware) {\r\n        this.app.use(middleware);\r\n    }\r\n\r\n    public start(port: number) {\r\n        this.server = this.app.listen(port, () => {\r\n            elizaLogger.success(\r\n                `REST API bound to 0.0.0.0:${port}. If running locally, access it at http://localhost:${port}.`\r\n            );\r\n        });\r\n\r\n        // Handle graceful shutdown\r\n        const gracefulShutdown = () => {\r\n            elizaLogger.log(\"Received shutdown signal, closing server...\");\r\n            this.server.close(() => {\r\n                elizaLogger.success(\"Server closed successfully\");\r\n                process.exit(0);\r\n            });\r\n\r\n            // Force close after 5 seconds if server hasn't closed\r\n            setTimeout(() => {\r\n                elizaLogger.error(\r\n                    \"Could not close connections in time, forcefully shutting down\"\r\n                );\r\n                process.exit(1);\r\n            }, 5000);\r\n        };\r\n\r\n        // Handle different shutdown signals\r\n        process.on(\"SIGTERM\", gracefulShutdown);\r\n        process.on(\"SIGINT\", gracefulShutdown);\r\n    }\r\n\r\n    public async stop() {\r\n        if (this.server) {\r\n            this.server.close(() => {\r\n                elizaLogger.success(\"Server stopped\");\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport const DirectClientInterface: Client = {\r\n    name: \"direct\",\r\n    config: {},\r\n    start: async (_runtime: IAgentRuntime) => {\r\n        elizaLogger.log(\"DirectClientInterface start\");\r\n        const client = new DirectClient();\r\n        const serverPort = Number.parseInt(settings.SERVER_PORT || \"3000\");\r\n        client.start(serverPort);\r\n        return client;\r\n    },\r\n    // stop: async (_runtime: IAgentRuntime, client?: Client) => {\r\n    //     if (client instanceof DirectClient) {\r\n    //         client.stop();\r\n    //     }\r\n    // },\r\n};\r\n\r\nconst directPlugin: Plugin = {\r\n    name: \"direct\",\r\n    description: \"Direct client\",\r\n    clients: [DirectClientInterface],\r\n};\r\nexport default directPlugin;\r\n","import express from \"express\";\r\nimport type { Router } from 'express';\r\nimport bodyParser from \"body-parser\";\r\nimport cors from \"cors\";\r\nimport path from \"path\";\r\nimport fs from \"fs\";\r\n\r\nimport {\r\n    type AgentRuntime,\r\n    elizaLogger,\r\n    getEnvVariable,\r\n    type UUID,\r\n    validateCharacterConfig,\r\n    ServiceType,\r\n    type Character,\r\n} from \"@elizaos/core\";\r\n\r\n// import type { TeeLogQuery, TeeLogService } from \"@elizaos/plugin-tee-log\";\r\n// import { REST, Routes } from \"discord.js\";\r\nimport type { DirectClient } from \".\";\r\nimport { validateUuid } from \"@elizaos/core\";\r\n\r\ninterface UUIDParams {\r\n    agentId: UUID;\r\n    roomId?: UUID;\r\n}\r\n\r\nfunction validateUUIDParams(\r\n    params: { agentId: string; roomId?: string },\r\n    res: express.Response\r\n): UUIDParams | null {\r\n    const agentId = validateUuid(params.agentId);\r\n    if (!agentId) {\r\n        res.status(400).json({\r\n            error: \"Invalid AgentId format. Expected to be a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\r\n        });\r\n        return null;\r\n    }\r\n\r\n    if (params.roomId) {\r\n        const roomId = validateUuid(params.roomId);\r\n        if (!roomId) {\r\n            res.status(400).json({\r\n                error: \"Invalid RoomId format. Expected to be a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\r\n            });\r\n            return null;\r\n        }\r\n        return { agentId, roomId };\r\n    }\r\n\r\n    return { agentId };\r\n}\r\n\r\nexport function createApiRouter(\r\n    agents: Map<string, IAgentRuntime>,\r\n    directClient: DirectClient\r\n):Router {\r\n    const router = express.Router();\r\n\r\n    router.use(cors());\r\n    router.use(bodyParser.json());\r\n    router.use(bodyParser.urlencoded({ extended: true }));\r\n    router.use(\r\n        express.json({\r\n            limit: getEnvVariable(\"EXPRESS_MAX_PAYLOAD\") || \"100kb\",\r\n        })\r\n    );\r\n\r\n    router.get(\"/\", (req, res) => {\r\n        res.send(\"Welcome, this is the REST API!\");\r\n    });\r\n\r\n    router.get(\"/hello\", (req, res) => {\r\n        res.json({ message: \"Hello World!\" });\r\n    });\r\n\r\n    router.get(\"/agents\", (req, res) => {\r\n        const agentsList = Array.from(agents.values()).map((agent) => ({\r\n            id: agent.agentId,\r\n            name: agent.character.name,\r\n            clients: Object.keys(agent.clients),\r\n        }));\r\n        res.json({ agents: agentsList });\r\n    });\r\n\r\n    router.get('/storage', async (req, res) => {\r\n        try {\r\n            const uploadDir = path.join(process.cwd(), \"data\", \"characters\");\r\n            const files = await fs.promises.readdir(uploadDir);\r\n            res.json({ files });\r\n        } catch (error) {\r\n            res.status(500).json({ error: error.message });\r\n        }\r\n    });\r\n\r\n    router.get(\"/agents/:agentId\", (req, res) => {\r\n        const { agentId } = validateUUIDParams(req.params, res) ?? {\r\n            agentId: null,\r\n        };\r\n        if (!agentId) return;\r\n\r\n        const agent = agents.get(agentId);\r\n\r\n        if (!agent) {\r\n            res.status(404).json({ error: \"Agent not found\" });\r\n            return;\r\n        }\r\n\r\n        const character = agent?.character;\r\n        if (character?.settings?.secrets) {\r\n            delete character.settings.secrets;\r\n        }\r\n\r\n        res.json({\r\n            id: agent.agentId,\r\n            character: agent.character,\r\n        });\r\n    });\r\n\r\n    router.delete(\"/agents/:agentId\", async (req, res) => {\r\n        const { agentId } = validateUUIDParams(req.params, res) ?? {\r\n            agentId: null,\r\n        };\r\n        if (!agentId) return;\r\n\r\n        const agent: AgentRuntime = agents.get(agentId);\r\n\r\n        if (agent) {\r\n            agent.stop();\r\n            directClient.unregisterAgent(agent);\r\n            res.status(204).json({ success: true });\r\n        } else {\r\n            res.status(404).json({ error: \"Agent not found\" });\r\n        }\r\n    });\r\n\r\n    router.post(\"/agents/:agentId/set\", async (req, res) => {\r\n        const { agentId } = validateUUIDParams(req.params, res) ?? {\r\n            agentId: null,\r\n        };\r\n        if (!agentId) return;\r\n\r\n        let agent: AgentRuntime = agents.get(agentId);\r\n\r\n        // update character\r\n        if (agent) {\r\n            // stop agent\r\n            agent.stop();\r\n            directClient.unregisterAgent(agent);\r\n            // if it has a different name, the agentId will change\r\n        }\r\n\r\n        // stores the json data before it is modified with added data\r\n        const characterJson = { ...req.body };\r\n\r\n        // load character from body\r\n        const character = req.body;\r\n        try {\r\n            validateCharacterConfig(character);\r\n        } catch (e) {\r\n            elizaLogger.error(`Error parsing character: ${e}`);\r\n            res.status(400).json({\r\n                success: false,\r\n                message: e.message,\r\n            });\r\n            return;\r\n        }\r\n\r\n        // start it up (and register it)\r\n        try {\r\n            agent = await directClient.startAgent(character);\r\n            elizaLogger.log(`${character.name} started`);\r\n        } catch (e) {\r\n            elizaLogger.error(`Error starting agent: ${e}`);\r\n            res.status(500).json({\r\n                success: false,\r\n                message: e.message,\r\n            });\r\n            return;\r\n        }\r\n\r\n        if (process.env.USE_CHARACTER_STORAGE === \"true\") {\r\n            try {\r\n                const filename = `${agent.agentId}.json`;\r\n                const uploadDir = path.join(\r\n                    process.cwd(),\r\n                    \"data\",\r\n                    \"characters\"\r\n                );\r\n                const filepath = path.join(uploadDir, filename);\r\n                await fs.promises.mkdir(uploadDir, { recursive: true });\r\n                await fs.promises.writeFile(\r\n                    filepath,\r\n                    JSON.stringify(\r\n                        { ...characterJson, id: agent.agentId },\r\n                        null,\r\n                        2\r\n                    )\r\n                );\r\n                elizaLogger.info(\r\n                    `Character stored successfully at ${filepath}`\r\n                );\r\n            } catch (error) {\r\n                elizaLogger.error(\r\n                    `Failed to store character: ${error.message}`\r\n                );\r\n            }\r\n        }\r\n\r\n        res.json({\r\n            id: character.id,\r\n            character: character,\r\n        });\r\n    });\r\n\r\n    // router.get(\"/agents/:agentId/channels\", async (req, res) => {\r\n    //     const { agentId } = validateUUIDParams(req.params, res) ?? {\r\n    //         agentId: null,\r\n    //     };\r\n    //     if (!agentId) return;\r\n\r\n    //     const runtime = agents.get(agentId);\r\n\r\n    //     if (!runtime) {\r\n    //         res.status(404).json({ error: \"Runtime not found\" });\r\n    //         return;\r\n    //     }\r\n\r\n    //     const API_TOKEN = runtime.getSetting(\"DISCORD_API_TOKEN\") as string;\r\n    //     const rest = new REST({ version: \"10\" }).setToken(API_TOKEN);\r\n\r\n    //     try {\r\n    //         const guilds = (await rest.get(Routes.userGuilds())) as Array<any>;\r\n\r\n    //         res.json({\r\n    //             id: runtime.agentId,\r\n    //             guilds: guilds,\r\n    //             serverCount: guilds.length,\r\n    //         });\r\n    //     } catch (error) {\r\n    //         console.error(\"Error fetching guilds:\", error);\r\n    //         res.status(500).json({ error: \"Failed to fetch guilds\" });\r\n    //     }\r\n    // });\r\n\r\n    router.get(\"/agents/:agentId/:roomId/memories\", async (req, res) => {\r\n        const { agentId, roomId } = validateUUIDParams(req.params, res) ?? {\r\n            agentId: null,\r\n            roomId: null,\r\n        };\r\n        if (!agentId || !roomId) return;\r\n\r\n        let runtime = agents.get(agentId);\r\n\r\n        // if runtime is null, look for runtime with the same name\r\n        if (!runtime) {\r\n            runtime = Array.from(agents.values()).find(\r\n                (a) => a.character.name.toLowerCase() === agentId.toLowerCase()\r\n            );\r\n        }\r\n\r\n        if (!runtime) {\r\n            res.status(404).send(\"Agent not found\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const memories = await runtime.messageManager.getMemories({\r\n                roomId,\r\n            });\r\n            const response = {\r\n                agentId,\r\n                roomId,\r\n                memories: memories.map((memory) => ({\r\n                    id: memory.id,\r\n                    userId: memory.userId,\r\n                    agentId: memory.agentId,\r\n                    createdAt: memory.createdAt,\r\n                    content: {\r\n                        text: memory.content.text,\r\n                        action: memory.content.action,\r\n                        source: memory.content.source,\r\n                        url: memory.content.url,\r\n                        inReplyTo: memory.content.inReplyTo,\r\n                        attachments: memory.content.attachments?.map(\r\n                            (attachment) => ({\r\n                                id: attachment.id,\r\n                                url: attachment.url,\r\n                                title: attachment.title,\r\n                                source: attachment.source,\r\n                                description: attachment.description,\r\n                                text: attachment.text,\r\n                                contentType: attachment.contentType,\r\n                            })\r\n                        ),\r\n                    },\r\n                    embedding: memory.embedding,\r\n                    roomId: memory.roomId,\r\n                    unique: memory.unique,\r\n                    similarity: memory.similarity,\r\n                })),\r\n            };\r\n\r\n            res.json(response);\r\n        } catch (error) {\r\n            console.error(\"Error fetching memories:\", error);\r\n            res.status(500).json({ error: \"Failed to fetch memories\" });\r\n        }\r\n    });\r\n\r\n    // router.get(\"/tee/agents\", async (req, res) => {\r\n    //     try {\r\n    //         const allAgents = [];\r\n\r\n    //         for (const agentRuntime of agents.values()) {\r\n    //             const teeLogService = agentRuntime\r\n    //                 .getService<TeeLogService>(ServiceType.TEE_LOG)\r\n    //                 .getInstance();\r\n\r\n    //             const agents = await teeLogService.getAllAgents();\r\n    //             allAgents.push(...agents);\r\n    //         }\r\n\r\n    //         const runtime: AgentRuntime = agents.values().next().value;\r\n    //         const teeLogService = runtime\r\n    //             .getService<TeeLogService>(ServiceType.TEE_LOG)\r\n    //             .getInstance();\r\n    //         const attestation = await teeLogService.generateAttestation(\r\n    //             JSON.stringify(allAgents)\r\n    //         );\r\n    //         res.json({ agents: allAgents, attestation: attestation });\r\n    //     } catch (error) {\r\n    //         elizaLogger.error(\"Failed to get TEE agents:\", error);\r\n    //         res.status(500).json({\r\n    //             error: \"Failed to get TEE agents\",\r\n    //         });\r\n    //     }\r\n    // });\r\n\r\n    // router.get(\"/tee/agents/:agentId\", async (req, res) => {\r\n    //     try {\r\n    //         const agentId = req.params.agentId;\r\n    //         const agentRuntime = agents.get(agentId);\r\n    //         if (!agentRuntime) {\r\n    //             res.status(404).json({ error: \"Agent not found\" });\r\n    //             return;\r\n    //         }\r\n\r\n    //         const teeLogService = agentRuntime\r\n    //             .getService<TeeLogService>(ServiceType.TEE_LOG)\r\n    //             .getInstance();\r\n\r\n    //         const teeAgent = await teeLogService.getAgent(agentId);\r\n    //         const attestation = await teeLogService.generateAttestation(\r\n    //             JSON.stringify(teeAgent)\r\n    //         );\r\n    //         res.json({ agent: teeAgent, attestation: attestation });\r\n    //     } catch (error) {\r\n    //         elizaLogger.error(\"Failed to get TEE agent:\", error);\r\n    //         res.status(500).json({\r\n    //             error: \"Failed to get TEE agent\",\r\n    //         });\r\n    //     }\r\n    // });\r\n\r\n    // router.post(\r\n    //     \"/tee/logs\",\r\n    //     async (req: express.Request, res: express.Response) => {\r\n    //         try {\r\n    //             const query = req.body.query || {};\r\n    //             const page = Number.parseInt(req.body.page) || 1;\r\n    //             const pageSize = Number.parseInt(req.body.pageSize) || 10;\r\n\r\n    //             const teeLogQuery: TeeLogQuery = {\r\n    //                 agentId: query.agentId || \"\",\r\n    //                 roomId: query.roomId || \"\",\r\n    //                 userId: query.userId || \"\",\r\n    //                 type: query.type || \"\",\r\n    //                 containsContent: query.containsContent || \"\",\r\n    //                 startTimestamp: query.startTimestamp || undefined,\r\n    //                 endTimestamp: query.endTimestamp || undefined,\r\n    //             };\r\n    //             const agentRuntime: AgentRuntime = agents.values().next().value;\r\n    //             const teeLogService = agentRuntime\r\n    //                 .getService<TeeLogService>(ServiceType.TEE_LOG)\r\n    //                 .getInstance();\r\n    //             const pageQuery = await teeLogService.getLogs(\r\n    //                 teeLogQuery,\r\n    //                 page,\r\n    //                 pageSize\r\n    //             );\r\n    //             const attestation = await teeLogService.generateAttestation(\r\n    //                 JSON.stringify(pageQuery)\r\n    //             );\r\n    //             res.json({\r\n    //                 logs: pageQuery,\r\n    //                 attestation: attestation,\r\n    //             });\r\n    //         } catch (error) {\r\n    //             elizaLogger.error(\"Failed to get TEE logs:\", error);\r\n    //             res.status(500).json({\r\n    //                 error: \"Failed to get TEE logs\",\r\n    //             });\r\n    //         }\r\n    //     }\r\n    // );\r\n\r\n    router.post(\"/agent/start\", async (req, res) => {\r\n        const { characterPath, characterJson } = req.body;\r\n        console.log(\"characterPath:\", characterPath);\r\n        console.log(\"characterJson:\", characterJson);\r\n        try {\r\n            let character: Character;\r\n            if (characterJson) {\r\n                character = await directClient.jsonToCharacter(\r\n                    characterPath,\r\n                    characterJson\r\n                );\r\n            } else if (characterPath) {\r\n                character =\r\n                    await directClient.loadCharacterTryPath(characterPath);\r\n            } else {\r\n                throw new Error(\"No character path or JSON provided\");\r\n            }\r\n            await directClient.startAgent(character);\r\n            elizaLogger.log(`${character.name} started`);\r\n\r\n            res.json({\r\n                id: character.id,\r\n                character: character,\r\n            });\r\n        } catch (e) {\r\n            elizaLogger.error(`Error parsing character: ${e}`);\r\n            res.status(400).json({\r\n                error: e.message,\r\n            });\r\n            return;\r\n        }\r\n    });\r\n\r\n    router.post(\"/agents/:agentId/stop\", async (req, res) => {\r\n        const agentId = req.params.agentId;\r\n        console.log(\"agentId\", agentId);\r\n        const agent: AgentRuntime = agents.get(agentId);\r\n\r\n        // update character\r\n        if (agent) {\r\n            // stop agent\r\n            agent.stop();\r\n            directClient.unregisterAgent(agent);\r\n            // if it has a different name, the agentId will change\r\n            res.json({ success: true });\r\n        } else {\r\n            res.status(404).json({ error: \"Agent not found\" });\r\n        }\r\n    });\r\n\r\n    return router;\r\n}\r\n","import express from \"express\";\r\nimport type { Router } from 'express';\r\nimport bodyParser from \"body-parser\";\r\nimport cors from \"cors\";\r\n\r\nimport { type AgentRuntime, elizaLogger, ServiceType }  from \"@elizaos/core\";\r\nimport type {\r\n    VerifiableLogService,\r\n    VerifiableLogQuery,\r\n} from \"@elizaos/plugin-tee-verifiable-log\";\r\n\r\nexport function createVerifiableLogApiRouter(\r\n    agents: Map<string, IAgentRuntime>\r\n):Router {\r\n    const router = express.Router();\r\n    router.use(cors());\r\n    router.use(bodyParser.json());\r\n    router.use(bodyParser.urlencoded({ extended: true }));\r\n\r\n    router.get(\r\n        \"/verifiable/agents\",\r\n        async (req: express.Request, res: express.Response) => {\r\n            try {\r\n                // call the listAgent method\r\n                const agentRuntime: AgentRuntime | undefined = agents.values().next().value;\r\n                const pageQuery = await agentRuntime\r\n                    .getService<VerifiableLogService>(\r\n                        ServiceType.VERIFIABLE_LOGGING\r\n                    )\r\n                    .listAgent();\r\n\r\n                res.json({\r\n                    success: true,\r\n                    message: \"Successfully get Agents\",\r\n                    data: pageQuery,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Detailed error:\", error);\r\n                res.status(500).json({\r\n                    error: \"failed to get agents registered \",\r\n                    details: error.message,\r\n                    stack: error.stack,\r\n                });\r\n            }\r\n        }\r\n    );\r\n    router.post(\r\n        \"/verifiable/attestation\",\r\n        async (req: express.Request, res: express.Response) => {\r\n            try {\r\n                const query = req.body || {};\r\n\r\n                const verifiableLogQuery = {\r\n                    agentId: query.agentId || \"\",\r\n                    publicKey: query.publicKey || \"\",\r\n                };\r\n                const agentRuntime: AgentRuntime | undefined = agents.values().next().value;\r\n                const pageQuery = await agentRuntime\r\n                    .getService<VerifiableLogService>(\r\n                        ServiceType.VERIFIABLE_LOGGING\r\n                    )\r\n                    .generateAttestation(verifiableLogQuery);\r\n\r\n                res.json({\r\n                    success: true,\r\n                    message: \"Successfully get Attestation\",\r\n                    data: pageQuery,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Detailed error:\", error);\r\n                res.status(500).json({\r\n                    error: \"Failed to Get Attestation\",\r\n                    details: error.message,\r\n                    stack: error.stack,\r\n                });\r\n            }\r\n        }\r\n    );\r\n    router.post(\r\n        \"/verifiable/logs\",\r\n        async (req: express.Request, res: express.Response) => {\r\n            try {\r\n                const query = req.body.query || {};\r\n                const page = Number.parseInt(req.body.page) || 1;\r\n                const pageSize = Number.parseInt(req.body.pageSize) || 10;\r\n\r\n                const verifiableLogQuery: VerifiableLogQuery = {\r\n                    idEq: query.idEq || \"\",\r\n                    agentIdEq: query.agentIdEq || \"\",\r\n                    roomIdEq: query.roomIdEq || \"\",\r\n                    userIdEq: query.userIdEq || \"\",\r\n                    typeEq: query.typeEq || \"\",\r\n                    contLike: query.contLike || \"\",\r\n                    signatureEq: query.signatureEq || \"\",\r\n                };\r\n                const agentRuntime: AgentRuntime | undefined = agents.values().next().value;\r\n                const pageQuery = await agentRuntime\r\n                    .getService<VerifiableLogService>(\r\n                        ServiceType.VERIFIABLE_LOGGING\r\n                    )\r\n                    ?.pageQueryLogs(verifiableLogQuery, page, pageSize);\r\n\r\n                res.json({\r\n                    success: true,\r\n                    message: \"Successfully retrieved logs\",\r\n                    data: pageQuery,\r\n                });\r\n            } catch (error) {\r\n                elizaLogger.error(\"Detailed error:\", error);\r\n                res.status(500).json({\r\n                    error: \"Failed to Get Verifiable Logs\",\r\n                    details: error.message,\r\n                    stack: error.stack,\r\n                });\r\n            }\r\n        }\r\n    );\r\n\r\n    return router;\r\n}\r\n"],"mappings":"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","names":["elizaLogger","bodyParser","cors","express","fs","path","express","bodyParser","cors","elizaLogger","ServiceType","elizaLogger","express","cors","bodyParser","content","nearby","availableEmotes","resolve"]}